---
title: 2.5.3 Exemplo - Álgebra Simbólica
---

import CodePlayground from '@site/src/components/CodePlayground';

# 2.5.3  Exemplo: Álgebra Simbólica

A manipulação de expressões algébricas simbólicas é um processo complexo que ilustra muitos dos problemas mais difíceis que ocorrem no design de sistemas em larga escala. Um sistema de álgebra mostrará a estrutura orientada a dados de uma forma particularmente dramática. Além disso, ao estender nosso sistema genérico com operações sobre polinômios, veremos como a capacidade de incorporar diferentes representações pode ser crucial na construção de um sistema prático.

## Aritmética de Polinômios

Polinômios podem ser vistos como uma generalização de números ordinários. Eles podem ser adicionados, multiplicados e testados para igualdade. No entanto, a aritmética de polinômios é mais complexa que a aritmética ordinária.

### Adição de Polinômios

Para adicionar dois polinômios, somamos os termos de mesma ordem:

```
(3x² + 5x + 7) + (2x² + 4x + 1) = 5x² + 9x + 8
```

### Multiplicação de Polinômios

Para multiplicar polinômios, multiplicamos cada termo do primeiro polinômio por cada termo do segundo:

```
(3x + 2) × (5x + 1) = 15x² + 3x + 10x + 2 = 15x² + 13x + 2
```

## Representando Polinômios

Representamos um polinômio como uma lista de termos. Cada termo é um par contendo a ordem (grau) e o coeficiente:

<CodePlayground
  code={`// Representação de polinômio
// p(x) = 5x² + 3x + 7
// Representado como: list(list(2, 5), list(1, 3), list(0, 7))

function make_polynomial(variable, term_list) {
    return attach_tag("polynomial", pair(variable, term_list));
}

function variable(p) { return head(p); }

function term_list(p) { return tail(p); }

function is_same_variable(v1, v2) {
    return is_variable(v1) && is_variable(v2) && v1 === v2;
}

function is_variable(x) { return is_string(x); }`}
  height={350}
/>

## Operações em Listas de Termos

<CodePlayground
  code={`// Construtores e seletores para termos
function make_term(order, coeff) {
    return list(order, coeff);
}

function order(term) { return head(term); }

function coeff(term) { return head(tail(term)); }

// Adição de polinômios
function add_poly(p1, p2) {
    return is_same_variable(variable(p1), variable(p2))
           ? make_polynomial(variable(p1),
                            add_terms(term_list(p1), term_list(p2)))
           : error(list(p1, p2), "polys not in same var -- add_poly");
}

function add_terms(L1, L2) {
    if (is_empty_termlist(L1)) {
        return L2;
    } else if (is_empty_termlist(L2)) {
        return L1;
    } else {
        const t1 = first_term(L1);
        const t2 = first_term(L2);
        return order(t1) > order(t2)
               ? adjoin_term(t1, add_terms(rest_terms(L1), L2))
               : order(t1) < order(t2)
               ? adjoin_term(t2, add_terms(L1, rest_terms(L2)))
               : adjoin_term(make_term(order(t1),
                                       add(coeff(t1), coeff(t2))),
                            add_terms(rest_terms(L1), rest_terms(L2)));
    }
}`}
  height={600}
/>

## Multiplicação de Polinômios

<CodePlayground
  code={`function mul_poly(p1, p2) {
    return is_same_variable(variable(p1), variable(p2))
           ? make_polynomial(variable(p1),
                            mul_terms(term_list(p1), term_list(p2)))
           : error(list(p1, p2), "polys not in same var -- mul_poly");
}

function mul_terms(L1, L2) {
    return is_empty_termlist(L1)
           ? the_empty_termlist
           : add_terms(mul_term_by_all_terms(first_term(L1), L2),
                      mul_terms(rest_terms(L1), L2));
}

function mul_term_by_all_terms(t1, L) {
    if (is_empty_termlist(L)) {
        return the_empty_termlist;
    } else {
        const t2 = first_term(L);
        return adjoin_term(
            make_term(order(t1) + order(t2),
                     mul(coeff(t1), coeff(t2))),
            mul_term_by_all_terms(t1, rest_terms(L)));
    }
}`}
  height={450}
/>

## Hierarquia de Tipos: de Inteiros a Polinômios

O sistema cria uma abstração de dados recursiva onde:

- **Nível 1**: Números (inteiros, racionais, complexos)
- **Nível 2**: Polinômios com coeficientes numéricos
- **Nível 3**: Polinômios com coeficientes polinomiais (permitindo representação multivariada)

Essa recursão permite operações em polinômios cujos coeficientes são eles mesmos polinômios, tratando automaticamente aninhamento arbitrário através de mecanismos de dispatch orientados a dados.

Por exemplo, `p(x) = (3x + 2)y + 1` pode ser representado como um polinômio em y cujos coeficientes são polinômios em x.

## Exercícios

**Exercício 2.87**: Instale `is_equal_to_zero` para polinômios no sistema genérico aritmético.

**Exercício 2.88**: Estenda o sistema de polinômios para incluir subtração de polinômios.

**Exercício 2.89**: Defina funções que implementam a representação de lista de termos descrita acima como apropriada para polinômios densos.

**Exercício 2.90**: Suponha que queremos ter um sistema de polinômios que seja eficiente para ambos, polinômios esparsos e densos. Uma maneira de fazer isso é permitir que ambas as representações coexistam no sistema.

**Exercício 2.91**: Implemente divisão de polinômios.

**Exercício 2.92**: Estenda o sistema de polinômios para permitir polinômios em diferentes variáveis serem adicionados.

**Exercício 2.93-2.97**: Estes exercícios exploram sistemas de álgebra mais sofisticados, incluindo aritmética racional com coeficientes polinomiais, simplificação de expressões e cálculo de máximo divisor comum (GCD) para polinômios.
