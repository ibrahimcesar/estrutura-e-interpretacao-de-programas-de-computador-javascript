---
title: 2.2.2 Estruturas Hierárquicas
---

import CodePlayground from '@site/src/components/CodePlayground';

# 2.2.2  Estruturas Hierárquicas

A representação de sequências em termos de listas generaliza-se naturalmente para representar sequências cujos elementos podem ser eles mesmos sequências. Por exemplo, podemos considerar o objeto construído por:

<CodePlayground
  code={`pair(list(1, 2), list(3, 4));`}
  height={120}
/>

como uma lista de três itens, o primeiro dos quais é ele mesmo uma lista. De fato, esta é a essência das estruturas *hierárquicas*—estruturas feitas de partes, que são elas mesmas feitas de partes, e assim por diante.

Outra maneira de pensar sobre sequências cujos elementos são sequências é como *árvores*. Os elementos da sequência são os ramos da árvore, e elementos que são eles mesmos sequências são subárvores.

## Contando Folhas

A recursão é uma ferramenta natural para lidar com estruturas de árvore, já que podemos frequentemente reduzir operações em árvores a operações em seus ramos. Como um exemplo, considere a operação de contar as folhas de uma árvore:

<CodePlayground
  code={`function count_leaves(x) {
    return is_null(x)
           ? 0
           : !is_pair(x)
           ? 1
           : count_leaves(head(x)) +
             count_leaves(tail(x));
}

const x = pair(list(1, 2), list(3, 4));

count_leaves(x);

count_leaves(list(x, x));`}
  height={350}
/>

## Mapeamento sobre Árvores

Assim como `map` é uma abstração poderosa para lidar com sequências, `tree_map` é uma abstração poderosa para lidar com árvores:

<CodePlayground
  code={`function scale_tree(tree, factor) {
    return is_null(tree)
           ? null
           : !is_pair(tree)
           ? tree * factor
           : pair(scale_tree(head(tree), factor),
                  scale_tree(tail(tree), factor));
}

scale_tree(list(1, list(2, list(3, 4), 5), list(6, 7)), 10);`}
  height={250}
/>

Podemos abstrair isso usando `map` junto com recursão:

<CodePlayground
  code={`function tree_map(fun, tree) {
    return map(sub_tree =>
                   !is_pair(sub_tree)
                   ? fun(sub_tree)
                   : tree_map(fun, sub_tree),
               tree);
}

function square_tree(tree) {
    return tree_map(x => x * x, tree);
}

square_tree(list(1, list(2, list(3, 4), 5), list(6, 7)));`}
  height={300}
/>

## Exercícios

**Exercício 2.24**: Suponha que avaliamos a expressão `list(1, list(2, list(3, 4)))`. Desenhe a representação box-and-pointer e a interpretação como árvore.

**Exercício 2.25**: Dê combinações de `head` e `tail` que selecionam 7 de cada uma das seguintes listas: `list(1, 3, list(5, 7), 9)`, `list(list(7))`, e `list(1, list(2, list(3, list(4, list(5, list(6, 7))))))`.

**Exercício 2.26**: Suponha que definimos `x` e `y` como listas. Qual é o resultado de `pair(x, y)`, `list(x, y)` e `append(x, y)`?

**Exercício 2.27**: Modifique sua função `reverse` do exercício 2.18 para produzir uma função `deep_reverse` que inverte todos os níveis de uma estrutura de árvore aninhada.

**Exercício 2.28**: Escreva uma função `fringe` que recebe uma árvore como argumento e retorna uma lista cujos elementos são todas as folhas da árvore organizadas da esquerda para a direita.

**Exercício 2.29**: Implemente um sistema de mobile binário (estrutura de equilíbrio) usando listas. Defina construtores e seletores, e funções para calcular peso total e verificar se o mobile está equilibrado.

**Exercício 2.30**: Defina uma função `square_tree` análoga à função `square_list` da seção anterior.

**Exercício 2.31**: Abstraia sua resposta ao exercício 2.30 para produzir uma função `tree_map` com a propriedade de que `square_tree` poderia ser definida como: `function square_tree(tree) { return tree_map(square, tree); }`.

**Exercício 2.32**: Complete a definição da função que gera o conjunto de subconjuntos de um conjunto.
