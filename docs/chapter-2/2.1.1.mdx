---
title: 2.1.1 Exemplo - Operações Aritméticas para Números Racionais
---

import CodePlayground from '@site/src/components/CodePlayground';

# 2.1.1  Exemplo: Operações Aritméticas para Números Racionais

Suponha que queremos fazer aritmética com números racionais. Queremos ser capazes de adicioná-los, subtraí-los, multiplicá-los e dividi-los, e testar se dois números racionais são iguais.

Vamos começar assumindo que já temos uma maneira de construir um número racional a partir de um numerador e um denominador. Também assumimos que, dado um número racional, temos uma maneira de extrair (ou selecionar) seu numerador e seu denominador. Vamos supor ainda que o construtor e os seletores estão disponíveis como funções:

* `make_rat(n, d)` retorna o número racional cujo numerador é o inteiro n e cujo denominador é o inteiro d.
* `numer(x)` retorna o numerador do número racional x.
* `denom(x)` retorna o denominador do número racional x.

Estamos usando aqui uma estratégia poderosa de síntese: *wishful thinking* (pensamento positivo). Ainda não dissemos como um número racional é representado, ou como as funções `numer`, `denom` e `make_rat` devem ser implementadas. Mesmo assim, se tivéssemos essas três funções, poderíamos então adicionar, subtrair, multiplicar, dividir e testar a igualdade usando as seguintes relações:

$$
\begin{array}{rll}
\dfrac{n_{1}}{d_{1}}+\dfrac{n_{2}}{d_{2}}
&=&\dfrac{n_{1}d_{2}+n_{2}d_{1}}{d_{1}d_{2}}\\[15pt]
\dfrac{n_{1}}{d_{1}}-\dfrac{n_{2}}{d_{2}}
&=&\dfrac{n_{1}d_{2}-n_{2}d_{1}}{d_{1}d_{2}}\\[15pt]
\dfrac{n_{1}}{d_{1}}\cdot\dfrac{n_{2}}{d_{2}}
&=&\dfrac{n_{1}n_{2}}{d_{1}d_{2}}\\[15pt]
\dfrac{n_{1}/d_{1}}{n_{2}/d_{2}}
&=&\dfrac{n_{1}d_{2}}{d_{1}n_{2}}\\[15pt]
\dfrac{n_{1}}{d_{1}}
&=&\dfrac{n_{2}}{d_{2}}\ \quad \textrm{se e somente se}\ \ \  n_{1}d_{2}\ =\ n_{2}d_{1}
\end{array}
$$

Podemos expressar essas regras como funções:

<CodePlayground
  code={`function add_rat(x, y) {
    return make_rat(numer(x) * denom(y) + numer(y) * denom(x),
                    denom(x) * denom(y));
}
function sub_rat(x, y) {
    return make_rat(numer(x) * denom(y) - numer(y) * denom(x),
                    denom(x) * denom(y));
}
function mul_rat(x, y) {
    return make_rat(numer(x) * numer(y),
                    denom(x) * denom(y));
}
function div_rat(x, y) {
    return make_rat(numer(x) * denom(y),
                    denom(x) * numer(y));
}
function equal_rat(x, y) {
    return numer(x) * denom(y) === numer(y) * denom(x);
}`}
  height={400}
/>

Agora temos as operações em números racionais definidas em termos das funções seletoras e construtoras `numer`, `denom` e `make_rat`. Mas ainda não definimos essas funções. O que precisamos é de alguma maneira de colar um numerador e um denominador para formar um número racional.

## Pares

Para nos permitir implementar o nível concreto de nossa abstração de dados, nosso ambiente JavaScript fornece uma estrutura composta chamada *par* (pair), que pode ser construída com a função primitiva `pair`. Esta função recebe dois argumentos e retorna um objeto de dados composto que contém os dois argumentos como partes. Dado um par, podemos extrair as partes usando as funções primitivas `head` e `tail`. Assim, podemos usar `pair`, `head` e `tail` da seguinte forma:

<CodePlayground
  code={`const x = pair(1, 2);

head(x);`}
  height={150}
/>

<CodePlayground
  code={`const x = pair(1, 2);

tail(x);`}
  height={150}
/>

Observe que um par é um objeto de dados que pode receber um nome e ser manipulado, assim como um objeto de dados primitivo. Além disso, `pair` pode ser usado para formar pares cujos elementos são pares, e assim por diante:

<CodePlayground
  code={`const x = pair(1, 2);
const y = pair(3, 4);
const z = pair(x, y);

head(head(z));`}
  height={180}
/>

<CodePlayground
  code={`const x = pair(1, 2);
const y = pair(3, 4);
const z = pair(x, y);

head(tail(z));`}
  height={180}
/>

Na seção 2.2 veremos como essa capacidade de combinar pares significa que os pares podem ser usados como blocos de construção de propósito geral para criar todos os tipos de estruturas de dados complexas. O único primitivo de dados compostos *par*, implementado pelas funções `pair`, `head` e `tail`, é a única cola que precisamos. Objetos de dados construídos a partir de pares são chamados de dados *estruturados em lista*.

## Representando números racionais

Os pares oferecem uma maneira natural de completar o sistema de números racionais. Simplesmente representamos um número racional como um par de dois inteiros: um numerador e um denominador. Então `make_rat`, `numer` e `denom` são prontamente implementados da seguinte forma:

<CodePlayground
  code={`function make_rat(n, d) { return pair(n, d); }

function numer(x) { return head(x); }

function denom(x) { return tail(x); }`}
  height={180}
/>

Além disso, para exibir os resultados de nossos cálculos, podemos imprimir números racionais imprimindo o numerador, uma barra e o denominador. Usamos a função primitiva `stringify` para transformar qualquer valor (aqui um número) em uma string. O operador `+` em JavaScript é *sobrecarregado*; ele pode ser aplicado a dois números ou a duas strings, e no último caso ele retorna o resultado de *concatenar* as duas strings.

<CodePlayground
  code={`function make_rat(n, d) { return pair(n, d); }
function numer(x) { return head(x); }
function denom(x) { return tail(x); }

function print_rat(x) {
    return display(stringify(numer(x)) + " / " + stringify(denom(x)));
}

const one_half = make_rat(1, 2);

print_rat(one_half);`}
  height={300}
/>

Agora podemos experimentar nossas funções de números racionais:

<CodePlayground
  code={`function make_rat(n, d) { return pair(n, d); }
function numer(x) { return head(x); }
function denom(x) { return tail(x); }

function add_rat(x, y) {
    return make_rat(numer(x) * denom(y) + numer(y) * denom(x),
                    denom(x) * denom(y));
}
function mul_rat(x, y) {
    return make_rat(numer(x) * numer(y),
                    denom(x) * denom(y));
}

function print_rat(x) {
    return display(stringify(numer(x)) + " / " + stringify(denom(x)));
}

const one_half = make_rat(1, 2);
const one_third = make_rat(1, 3);

print_rat(add_rat(one_half, one_third));`}
  height={450}
/>

<CodePlayground
  code={`function make_rat(n, d) { return pair(n, d); }
function numer(x) { return head(x); }
function denom(x) { return tail(x); }

function mul_rat(x, y) {
    return make_rat(numer(x) * numer(y),
                    denom(x) * denom(y));
}

function print_rat(x) {
    return display(stringify(numer(x)) + " / " + stringify(denom(x)));
}

const one_half = make_rat(1, 2);
const one_third = make_rat(1, 3);

print_rat(mul_rat(one_half, one_third));`}
  height={400}
/>

<CodePlayground
  code={`function make_rat(n, d) { return pair(n, d); }
function numer(x) { return head(x); }
function denom(x) { return tail(x); }

function add_rat(x, y) {
    return make_rat(numer(x) * denom(y) + numer(y) * denom(x),
                    denom(x) * denom(y));
}

function print_rat(x) {
    return display(stringify(numer(x)) + " / " + stringify(denom(x)));
}

const one_third = make_rat(1, 3);

print_rat(add_rat(one_third, one_third));`}
  height={400}
/>

Como o exemplo final mostra, nossa implementação de números racionais não reduz os números racionais aos menores termos. Podemos remediar isso mudando `make_rat`. Se tivermos uma função `gcd` como a da seção 1.2.5 que produz o maior divisor comum de dois inteiros, podemos usar `gcd` para reduzir o numerador e o denominador aos menores termos antes de construir o par:

<CodePlayground
  code={`function gcd(a, b) {
    return b === 0 ? a : gcd(b, a % b);
}

function make_rat(n, d) {
    const g = gcd(n, d);
    return pair(n / g, d / g);
}

function numer(x) { return head(x); }
function denom(x) { return tail(x); }

function add_rat(x, y) {
    return make_rat(numer(x) * denom(y) + numer(y) * denom(x),
                    denom(x) * denom(y));
}

function print_rat(x) {
    return display(stringify(numer(x)) + " / " + stringify(denom(x)));
}

const one_third = make_rat(1, 3);

print_rat(add_rat(one_third, one_third));`}
  height={500}
/>

Agora temos o resultado desejado. Esta modificação foi realizada mudando o construtor `make_rat` sem mudar nenhuma das funções (como `add_rat` e `mul_rat`) que implementam as operações reais.

## Exercício 2.1

Defina uma versão melhor de `make_rat` que lida com argumentos positivos e negativos. A função `make_rat` deve normalizar o sinal de modo que, se o número racional for positivo, tanto o numerador quanto o denominador sejam positivos, e se o número racional for negativo, apenas o numerador seja negativo.

<CodePlayground
  code={`// Seu código aqui
function sign(x) {
    return x < 0
           ? -1
           : x > 0
             ? 1
             : 0;
}

function make_rat(n, d) {
    const g = gcd(n, d);
    // Complete a implementação
}`}
  height={250}
/>
