<SUBSECTION>
  <NAME>
    Programação Lógica é Lógica Matemática?
  </NAME>

  <LABEL NAME="sec:math-logic"/>

  <INDEX>query language<SUBINDEX>mathematical logic vs.<OPEN/></SUBINDEX></INDEX>
  <INDEX>logic programming<SUBINDEX>mathematical logic vs.<OPEN/></SUBINDEX></INDEX>

  <TEXT>
    Os meios de combinação usados na linguagem de consulta podem, à primeira vista, parecer
    idênticos às operações <SCHEMEINLINE>and</SCHEMEINLINE>,
    <SCHEMEINLINE>or</SCHEMEINLINE> e <SCHEMEINLINE>not</SCHEMEINLINE> da
    lógica matemática, e a aplicação de regras da linguagem de consulta é de fato
    realizada através de um método legítimo de
    <INDEX>inference, method of</INDEX>
    inferência.<FOOTNOTE>Que um método particular de inferência seja
    legítimo não é uma afirmação trivial. É preciso provar que, se começarmos
    com premissas verdadeiras, apenas conclusões verdadeiras podem ser derivadas. O
    método de inferência representado por aplicações de regras é
    <INDEX><ORDER>modus</ORDER><EM>modus ponens</EM></INDEX>
    <EM>modus ponens</EM>,
    o familiar método de inferência que diz que se <EM>A</EM> é
    verdadeiro e <EM>A implica B</EM> é verdadeiro, então podemos concluir que <EM>B</EM>
    é verdadeiro.</FOOTNOTE> Esta identificação da linguagem de consulta com
    a lógica matemática não é realmente válida, no entanto, porque a linguagem de consulta
    fornece uma
    <INDEX>control structure</INDEX>
    <EM>estrutura de controle</EM> que interpreta as declarações lógicas
    procedimentalmente. Podemos frequentemente tirar proveito dessa estrutura de controle.
    Por exemplo, para encontrar todos os supervisores de programadores, poderíamos
    formular uma consulta em qualquer uma de duas formas logicamente equivalentes:
    <SNIPPET EVAL="no">
      <SCHEME>
(and (job ?x (computer programmer))
     (supervisor ?x ?y))
      </SCHEME>
      <JAVASCRIPT>
and(job($x, list("computer", "programmer")),
    supervisor($x, $y))
      </JAVASCRIPT>
    </SNIPPET>
    ou
    <SNIPPET EVAL="no">
      <SCHEME>
(and (supervisor ?x ?y)
     (job ?x (computer programmer)))
      </SCHEME>
      <JAVASCRIPT>
and(supervisor($x, $y),
    job($x, list("computer", "programmer")))
      </JAVASCRIPT>
    </SNIPPET>
    Se uma empresa tem
    <INDEX>bureaucracy</INDEX>
    muito mais supervisores do que programadores,
    é melhor usar a primeira forma em vez da segunda,
    porque a base de dados deve ser escaneada para cada resultado intermediário
    (frame) produzido pela primeira cláusula do <SCHEMEINLINE>and</SCHEMEINLINE>.
  </TEXT>

  <SHORT_PAGE lines="2"/>
  <TEXT>
    O objetivo da programação lógica é fornecer ao programador
    técnicas para decompor um problema computacional em dois problemas separados:
    <INDEX>declarative vs.<SPACE/>imperative knowledge<SUBINDEX>logic programming and</SUBINDEX></INDEX>
    <INDEX>imperative vs.<SPACE/>declarative knowledge<SUBINDEX>logic programming and</SUBINDEX></INDEX>
    <QUOTE>o que</QUOTE> deve ser computado, e <QUOTE>como</QUOTE> isso
    deve ser computado. Isso é realizado selecionando um subconjunto das
    declarações da lógica matemática que seja poderoso o suficiente para ser capaz de
    descrever qualquer coisa que se possa querer computar, mas fraco o suficiente para ter uma
    interpretação procedimental controlável. A intenção aqui é que,
    por um lado, um programa especificado em uma linguagem de programação lógica
    deve ser um programa efetivo que pode ser executado por um computador.
    Controle (<QUOTE>como</QUOTE> computar) é efetivado usando a ordem de
    avaliação da linguagem. Devemos ser capazes de organizar a ordem das
    cláusulas e a ordem dos subobjetivos dentro de cada cláusula de modo que a
    computação seja feita em uma ordem considerada efetiva e eficiente.
    Ao mesmo tempo, devemos ser capazes de visualizar o resultado da
    computação (<QUOTE>o que</QUOTE> computar) como uma simples consequência das
    leis da lógica.
  </TEXT>

  <TEXT>
    Nossa linguagem de consulta pode ser considerada como apenas tal subconjunto procedimentalmente
    interpretável da lógica matemática. Uma asserção representa um
    fato simples (uma proposição atômica). Uma regra representa a
    implicação de que a conclusão da regra vale para aqueles casos em que o
    corpo da regra vale. Uma regra tem uma interpretação procedimental natural: Para
    estabelecer a conclusão da regra, estabeleça o corpo da regra.
    Regras, portanto, especificam computações. No entanto, como as regras também
    podem ser consideradas declarações da lógica matemática, podemos justificar qualquer
    <QUOTE>inferência</QUOTE> realizada por um programa lógico afirmando que
    o mesmo resultado poderia ser obtido trabalhando inteiramente dentro da
    lógica matemática.<FOOTNOTE>Devemos qualificar esta afirmação
    concordando que, ao falar da <QUOTE>inferência</QUOTE> realizada
    por um programa lógico, assumimos que a computação termina.
    Infelizmente, até mesmo esta afirmação qualificada é falsa para nossa
    implementação da linguagem de consulta (e também falsa para programas em
    Prolog e na maioria das outras linguagens de programação lógica atuais) por causa
    de nosso uso de <SCHEMEINLINE>not</SCHEMEINLINE> e
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>lisp-value</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>javascript_predicate</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Como descreveremos abaixo, o <SCHEMEINLINE>not</SCHEMEINLINE> implementado
    na linguagem de consulta nem sempre é consistente com o
    <SCHEMEINLINE>not</SCHEMEINLINE> da lógica matemática, e
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>lisp-value</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>javascript_predicate</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    introduz complicações adicionais. Poderíamos implementar uma linguagem
    consistente com a lógica matemática simplesmente removendo
    <SCHEMEINLINE>not</SCHEMEINLINE> e
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>lisp-value</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>javascript_predicate</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    da linguagem e concordando em escrever programas usando apenas consultas simples,
    <SCHEMEINLINE>and</SCHEMEINLINE> e <SCHEMEINLINE>or</SCHEMEINLINE>.
    No entanto, isso restringiria muito o poder expressivo da linguagem.
    Uma das principais preocupações da pesquisa em programação lógica era encontrar maneiras
    de alcançar mais consistência com a lógica matemática sem sacrificar indevidamente
    o poder expressivo.</FOOTNOTE>
  </TEXT>

  <SUBHEADING>
    <NAME>Loops infinitos</NAME>
  </SUBHEADING>

  <INDEX>query interpreter<SUBINDEX>infinite loops<OPEN/></SUBINDEX></INDEX>

  <TEXT>
    Uma consequência da interpretação procedimental de programas lógicos é
    que é possível construir programas desesperadamente ineficientes para
    resolver certos problemas. Um caso extremo de ineficiência ocorre quando
    o sistema cai em loops infinitos ao fazer deduções. Como um
    exemplo simples, suponha que estamos configurando uma base de dados de casamentos famosos,
    incluindo
    <SNIPPET EVAL="no">
      <INDEX>Mouse, Minnie and Mickey</INDEX>
      <SCHEME>
(assert! (married Minnie Mickey))
      </SCHEME>
      <JAVASCRIPT>
assert(married("Minnie", "Mickey"))
      </JAVASCRIPT>
    </SNIPPET>
    Se agora perguntarmos
    <SNIPPET EVAL="no">
      <SCHEME>
(married Mickey ?who)
      </SCHEME>
      <JAVASCRIPT>
married("Mickey", $who)
      </JAVASCRIPT>
    </SNIPPET>
    não obteremos resposta, porque o sistema não sabe que se
    <LATEXINLINE>$A$</LATEXINLINE> é casado com <LATEXINLINE>$B$</LATEXINLINE>,
    então <LATEXINLINE>$B$</LATEXINLINE> é casado com
    <LATEXINLINE>$A$</LATEXINLINE>. Então afirmamos a regra
    <SNIPPET EVAL="no">
      <SCHEME>
(assert! (rule (married ?x ?y)
         (married ?y ?x)))
      </SCHEME>
      <JAVASCRIPT>
assert(rule(married($x, $y),
            married($y, $x)))
      </JAVASCRIPT>
    </SNIPPET>
    e consultamos novamente
    <SNIPPET EVAL="no">
      <SCHEME>
(married Mickey ?who)
      </SCHEME>
      <JAVASCRIPT>
married("Mickey", $who)
      </JAVASCRIPT>
    </SNIPPET>
    Infelizmente, isso levará o sistema a um loop infinito, da seguinte forma:
    <UL>
      <LI>
	<SPLITINLINE>
	  <SCHEME>
	    O sistema descobre que a regra <SCHEMEINLINE>married</SCHEMEINLINE> é
	    aplicável; ou seja, a conclusão da regra
	    <SCHEMEINLINE>(married ?x ?y)</SCHEMEINLINE>
	    unifica com sucesso com o padrão de consulta
	    <SCHEMEINLINE>(married Mickey ?who)</SCHEMEINLINE>
	    para produzir um frame no qual
	  </SCHEME>
	  <JAVASCRIPT>
	    O sistema descobre que a regra <SCHEMEINLINE>married</SCHEMEINLINE> é
	    aplicável; ou seja, a conclusão da regra
	    <JAVASCRIPTINLINE>married($x, $y)</JAVASCRIPTINLINE>
	    unifica com o padrão de consulta
	    <JAVASCRIPTINLINE>married("Mickey", $who)</JAVASCRIPTINLINE>
	    para produzir um frame no qual
	  </JAVASCRIPT>
	</SPLITINLINE>
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	está vinculado a
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>Mickey</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>"Mickey"</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	e
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>?y</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>$y</JAVASCRIPTINLINE></JAVASCRIPT>
	</SPLITINLINE>
	está vinculado a
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>?who</SCHEMEINLINE>.</SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>$who</JAVASCRIPTINLINE>.</JAVASCRIPT>
	</SPLITINLINE>
	Então o interpretador prossegue para avaliar o corpo da regra
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(married ?y ?x)</SCHEMEINLINE></SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>married($y, $x)</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	neste frame<EMDASH/>com efeito, para processar a consulta
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(married ?who Mickey)</SCHEMEINLINE>.</SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>married($who, "Mickey")</JAVASCRIPTINLINE>.
	  </JAVASCRIPT>
	</SPLITINLINE>
      </LI>
      <LI>
	<SPLITINLINE>
	  <SCHEME>
	    Uma resposta aparece diretamente como uma asserção na base de
	    dados:
	    <SCHEMEINLINE>(married Minnie Mickey)</SCHEMEINLINE>.
	  </SCHEME>
	  <JAVASCRIPT>
	    Uma resposta,
	    <JAVASCRIPTINLINE>married("Minnie", "Mickey")</JAVASCRIPTINLINE>,
	    aparece diretamente como uma asserção na base de dados.
	  </JAVASCRIPT>
	</SPLITINLINE>
      </LI>
      <LI>
	A regra <SCHEMEINLINE>married</SCHEMEINLINE> também é aplicável, então o
	interpretador novamente avalia o corpo da regra, que desta vez é equivalente
	a
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(married Mickey ?who)</SCHEMEINLINE>.</SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>married("Mickey", $who)</JAVASCRIPTINLINE>.
	  </JAVASCRIPT>
	</SPLITINLINE>
      </LI>
    </UL>
    O sistema está agora em um loop infinito. De fato, se o sistema
    encontrará a resposta simples
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(married Minnie Mickey)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>married("Minnie", "Mickey")</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    antes de entrar no loop depende de detalhes de implementação referentes à
    ordem na qual o sistema verifica os itens na base de dados. Este é um exemplo muito
    simples dos tipos de loops que podem ocorrer. Coleções de
    regras inter-relacionadas podem levar a loops muito mais difíceis de antecipar, e
    o aparecimento de um loop pode depender da ordem das cláusulas em um
    <SCHEMEINLINE>and</SCHEMEINLINE> (veja
    exercício<SPACE/><REF NAME="ex:query-simple-loop"/>) ou em detalhes de baixo nível
    referentes à ordem na qual o sistema processa consultas.<FOOTNOTE>Este não é
    um problema da lógica, mas da interpretação procedimental da
    lógica fornecida por nosso interpretador. Poderíamos escrever um interpretador que
    não cairia em um loop aqui. Por exemplo, poderíamos enumerar todas as provas
    deriváveis de nossas asserções e nossas regras em uma ordem de busca em largura em vez de uma
    ordem de busca em profundidade. No entanto, tal sistema torna mais difícil tirar
    proveito da ordem das deduções em nossos programas. Uma tentativa de
    construir controle sofisticado em tal programa é descrita em
    <INDEX>de Kleer, Johan</INDEX>
    <CITATION>de Kleer et al.<SPACE/>1977</CITATION>.
    Outra técnica, que não leva a problemas de controle tão sérios, é
    colocar conhecimento especial, como detectores para tipos particulares de loops
    (exercício<SPACE/><REF NAME="ex:query-loop-detector"/>). No entanto, não pode
    haver um esquema geral para prevenir confiavelmente um sistema de entrar em
    caminhos infinitos ao realizar deduções. Imagine uma regra diabólica da
    forma <QUOTE>Para mostrar que <LATEXINLINE>$P(x)$</LATEXINLINE> é verdadeiro, mostre que
    <LATEXINLINE>$P(f(x))$</LATEXINLINE> é verdadeiro,</QUOTE> para alguma função
    <LATEXINLINE>$f$</LATEXINLINE> adequadamente escolhida.</FOOTNOTE>
  </TEXT>

  <INDEX>query interpreter<SUBINDEX>infinite loops<CLOSE/></SUBINDEX></INDEX>

  <SUBHEADING>
    <NAME>Problemas com <SCHEMEINLINE>not</SCHEMEINLINE></NAME>
  </SUBHEADING>

  <INDEX>query interpreter<SUBINDEX>problems with <SCHEMEINLINE>not</SCHEMEINLINE> and <SCHEMEINLINE>javascript_predicate</SCHEMEINLINE><OPEN/></SUBINDEX></INDEX>

  <TEXT>
    Outra peculiaridade no sistema de consulta diz respeito a
    <INDEX><USE>not</USE> (query language)</INDEX>
    <SCHEMEINLINE>not</SCHEMEINLINE>.
    Dada a base de dados da
    seção<SPACE/><REF NAME="sec:deductive-info-retrieval"/>, considere as
    seguintes duas consultas:
    <SNIPPET EVAL="no">
      <SCHEME>
(and (supervisor ?x ?y)
     (not (job ?x (computer programmer))))

(and (not (job ?x (computer programmer)))
     (supervisor ?x ?y))
      </SCHEME>
      <JAVASCRIPT>
and(supervisor($x, $y),
    not(job($x, list("computer", "programmer"))))

and(not(job($x, list("computer", "programmer"))),
    supervisor($x, $y))
      </JAVASCRIPT>
    </SNIPPET>
    Estas duas consultas não produzem o mesmo resultado. A primeira consulta
    começa encontrando todas as entradas na base de dados que correspondem a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(supervisor ?x ?y)</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>supervisor($x, $y)</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    e então filtra os frames resultantes removendo aqueles nos quais o
    valor de
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    satisfaz
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>(job ?x (computer programmer))</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
  <JAVASCRIPTINLINE>job($x,@list("computer", "programmer"))</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    A segunda consulta começa filtrando os
    frames de entrada para remover aqueles que podem satisfazer
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>(job ?x (computer programmer))</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>job($x, list("computer",@"programmer"))</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Como o único frame de entrada é vazio, ele verifica a base de dados
    <SPLITINLINE>
      <SCHEME>
        para ver se há
      </SCHEME>
      <JAVASCRIPT>
        em busca de
      </JAVASCRIPT>
    </SPLITINLINE>
    padrões que satisfaçam
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>(job ?x (computer programmer))</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
        <JAVASCRIPTINLINE>job($x, list("computer", "programmer"))</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Como geralmente há entradas dessa forma, a
    cláusula <SCHEMEINLINE>not</SCHEMEINLINE> filtra o frame vazio e
    retorna um stream vazio de frames. Consequentemente, toda a consulta composta
    retorna um stream vazio.
  </TEXT>

  <TEXT>
    O problema é que nossa implementação de <SCHEMEINLINE>not</SCHEMEINLINE>
    realmente se destina a servir como um filtro em valores para as variáveis. Se uma
    cláusula <SCHEMEINLINE>not</SCHEMEINLINE> é processada com um frame no qual
    algumas das variáveis permanecem não vinculadas (como ocorre com
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>?x</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>$x</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    no exemplo acima), o sistema produzirá resultados inesperados. Problemas similares
    ocorrem com o uso de
    <INDEX><USE>javascript_predicate</USE> (query language)</INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>lisp-value</SCHEMEINLINE><EMDASH/>o</SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>javascript_@predicate</JAVASCRIPTINLINE><EMDASH/>o
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	predicado Lisp
	não pode funcionar se alguns de seus argumentos não estão vinculados.
      </SCHEME>
      <JAVASCRIPT>
	predicado JavaScript
	não pode funcionar se algumas de suas variáveis não estão vinculadas.
      </JAVASCRIPT>
    </SPLITINLINE>
    Veja exercício<SPACE/><REF NAME="ex:not-query-filter"/>.
  </TEXT>

  <TEXT>
    Há também uma maneira muito mais séria pela qual o
    <SCHEMEINLINE>not</SCHEMEINLINE> da linguagem de consulta difere do
    <SCHEMEINLINE>not</SCHEMEINLINE> da lógica matemática. Na lógica,
    interpretamos a declaração <QUOTE>not<SPACE/><LATEXINLINE>$P$</LATEXINLINE></QUOTE> como
    significando que <LATEXINLINE>$P$</LATEXINLINE> não é verdadeiro. No sistema de consulta,
    no entanto, <QUOTE>not <LATEXINLINE>$P$</LATEXINLINE></QUOTE> significa que
    <LATEXINLINE>$P$</LATEXINLINE> não é dedutível do conhecimento na
    base de dados. Por exemplo, dada a base de dados de pessoal da
    seção<SPACE/><REF NAME="sec:deductive-info-retrieval"/>, o sistema
    deduziria alegremente todos os tipos de declarações <SCHEMEINLINE>not</SCHEMEINLINE>,
    como que Ben Bitdiddle não é fã de beisebol, que não está chovendo
    lá fora, e que <LATEXINLINE>$2 + 2$</LATEXINLINE>
    não é 4.<FOOTNOTE>Considere a consulta
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(not (baseball-fan (Bitdiddle Ben)))</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>not(baseball_fan(list("Bitdiddle", "Ben")))</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    O sistema descobre que
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>(baseball-fan (Bitdiddle Ben))</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>baseball_fan(list("Bitdiddle", "Ben"))</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    não está na base de dados, então o frame vazio não satisfaz o padrão e
    não é filtrado do stream inicial de frames. O resultado da
    consulta é, portanto, o frame vazio, que é usado para instanciar a consulta de entrada
    para produzir
    <SPLITINLINE><SCHEME><SCHEMEINLINE>(not (baseball-fan (Bitdiddle Ben)))</SCHEMEINLINE></SCHEME><JAVASCRIPT><JAVASCRIPTINLINE>not(baseball_fan(list("Bitdiddle", "Ben")))</JAVASCRIPTINLINE></JAVASCRIPT></SPLITINLINE>.</FOOTNOTE> Em outras
    palavras, o <SCHEMEINLINE>not</SCHEMEINLINE> das linguagens de programação lógica
    reflete a chamada
    <INDEX>closed world assumption</INDEX>
    <EM>suposição de mundo fechado</EM> de que toda a informação relevante foi
    incluída na base de dados.<FOOTNOTE>Uma discussão e justificativa deste
    tratamento de <SCHEMEINLINE>not</SCHEMEINLINE> pode ser encontrada no artigo
    <INDEX>negation as failure</INDEX>
    <QUOTE>Negation as Failure</QUOTE> de
    <INDEX>Clark, Keith L.</INDEX>
    Clark (1978).</FOOTNOTE>
  </TEXT>
  <INDEX>query interpreter<SUBINDEX>problems with <SCHEMEINLINE>not</SCHEMEINLINE> and <SCHEMEINLINE>javascript_predicate</SCHEMEINLINE><CLOSE/></SUBINDEX></INDEX>

  <EXERCISE>
    Louis Reasoner apaga por engano a regra
    <INDEX><USE>outranked_by</USE> (rule)</INDEX>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>outranked-by</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>outranked_by</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    (seção<SPACE/><REF NAME="sec:deductive-info-retrieval"/>) da
    base de dados. Quando percebe isso, rapidamente a reinstala. Infelizmente,
    ele faz uma pequena mudança na regra e a digita como
    <SNIPPET EVAL="no">
      <SCHEME>
(rule (outranked-by ?staff-person ?boss)
      (or (supervisor ?staff-person ?boss)
          (and (outranked-by ?middle-manager ?boss)
               (supervisor ?staff-person ?middle-manager))))
      </SCHEME>
      <JAVASCRIPT>
rule(outranked_by($staff_person, $boss),
     or(supervisor($staff_person, $boss),
        and(outranked_by($middle_manager, $boss),
            supervisor($staff_person, $middle_manager))))
      </JAVASCRIPT>
    </SNIPPET>
    Logo após Louis digitar essa informação no sistema, DeWitt
    Aull vem descobrir quem está acima de Ben Bitdiddle. Ele emite
    a consulta
    <SNIPPET EVAL="no">
      <SCHEME>
(outranked-by (Bitdiddle Ben) ?who)
      </SCHEME>
      <JAVASCRIPT>
outranked_by(list("Bitdiddle", "Ben"), $who)
      </JAVASCRIPT>
    </SNIPPET>

    Após responder, o sistema entra em um loop infinito. Explique por quê.
    <LABEL NAME="ex:query-simple-loop"/>
  </EXERCISE>

  <EXERCISE>
    Cy D. Fect, ansioso pelo dia em que subirá na
    organização, faz uma consulta para encontrar todos os mandachuvas (usando a
    regra <INDEX><USE>wheel</USE> (rule)</INDEX>
    <SCHEMEINLINE>wheel</SCHEMEINLINE> da
    seção<SPACE/><REF NAME="sec:deductive-info-retrieval"/>):
    <SNIPPET EVAL="no">
      <SCHEME>
(wheel ?who)
      </SCHEME>
      <JAVASCRIPT>
wheel($who)
      </JAVASCRIPT>
    </SNIPPET>
    Para sua surpresa, o sistema responde
    <SNIPPET EVAL="no">
      <SCHEMEOUTPUT>
;;; Query results:
(wheel (Warbucks Oliver))
(wheel (Bitdiddle Ben))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
(wheel (Warbucks Oliver))
      </SCHEMEOUTPUT>
      <JAVASCRIPT_OUTPUT>
Query results:
wheel(list("Warbucks", "Oliver"))
wheel(list("Bitdiddle", "Ben"))
wheel(list("Warbucks", "Oliver"))
wheel(list("Warbucks", "Oliver"))
wheel(list("Warbucks", "Oliver"))
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    Por que Oliver Warbucks está listado quatro vezes?
    <LABEL NAME="ex:multiple-query"/>
  </EXERCISE>

  <EXERCISE>
    Ben tem
    <INDEX>query language<SUBINDEX>extensions to</SUBINDEX></INDEX>
    generalizado o sistema de consulta para fornecer estatísticas sobre a
    empresa. Por exemplo, para encontrar os salários totais de todos os
    programadores de computador, será possível dizer
    <SNIPPET EVAL="no">
      <SCHEME>
(sum ?amount
     (and (job ?x (computer programmer))
          (salary ?x ?amount)))
      </SCHEME>
      <JAVASCRIPT>
sum($amount,
    and(job($x, list("computer", "programmer")),
        salary($x, $amount)))
      </JAVASCRIPT>
    </SNIPPET>
    Em geral, o novo sistema de Ben permite expressões da forma
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
(accumulation-function variable
                       $\langle query$ $pattern\rangle$)
      </SCHEME>
      <JAVASCRIPT>
accumulation_function($variable$,
                      $query$-$pattern$)
      </JAVASCRIPT>
    </SNIPPET>
    onde
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>accumulation-function</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>accumulation_function</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    podem ser coisas como <SCHEMEINLINE>sum</SCHEMEINLINE>,
    <SCHEMEINLINE>average</SCHEMEINLINE> ou
    <SCHEMEINLINE>maximum</SCHEMEINLINE>.
    Ben raciocina que deve ser moleza implementar isso. Ele simplesmente
    alimentará o padrão de consulta para
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>qeval</SCHEMEINLINE>.</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>evaluate_query</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    Isso produzirá um stream de frames. Ele então passará esse stream através
    de uma função de mapeamento que extrai o valor da variável designada de
    cada frame no stream e alimentará o stream resultante de valores para a
    função de acumulação. Assim que Ben completa a implementação e está
    prestes a testá-la, Cy passa por ali, ainda intrigado com o
    resultado da consulta <SCHEMEINLINE>wheel</SCHEMEINLINE> no
    exercício<SPACE/><REF NAME="ex:multiple-query"/>. Quando Cy mostra a Ben a
    resposta do sistema, Ben geme, <QUOTE>Oh, não, meu esquema simples de acumulação
    não vai funcionar!</QUOTE>
    <P/>
    O que Ben acabou de perceber? Delineie um método que ele pode usar para salvar a
    situação.
    <LABEL NAME="ex:4_64"/>
  </EXERCISE>

  <EXERCISE>
    Invente uma
    <INDEX>query interpreter<SUBINDEX>improvements to</SUBINDEX></INDEX>
    <INDEX>query interpreter<SUBINDEX>infinite loops</SUBINDEX></INDEX>
    maneira de instalar um detector de loop no sistema de consulta para
    evitar os tipos de loops simples ilustrados no texto e no
    exercício<SPACE/><REF NAME="ex:query-simple-loop"/>. A ideia geral é
    que o sistema deve manter algum tipo de histórico de sua cadeia atual de
    deduções e não deve começar a processar uma consulta na qual já está
    trabalhando. Descreva que tipo de informação (padrões e frames)
    está incluída neste histórico, e como a verificação deve ser feita. (Depois
    de estudar os detalhes da implementação do sistema de consulta na
    seção<SPACE/><REF NAME="sec:implementing-the-query-system"/>, você pode
    querer modificar o sistema para incluir seu detector de loop.)
    <LABEL NAME="ex:query-loop-detector"/>
  </EXERCISE>

  <DO_BREAK_PAGE/>
  <EXERCISE>
    Defina regras para implementar a
    <INDEX><USE>reverse</USE><SUBINDEX>rules</SUBINDEX></INDEX>
    operação <SCHEMEINLINE>reverse</SCHEMEINLINE>
    do exercício<SPACE/><REF NAME="ex:reverse"/>, que retorna uma lista contendo
    os mesmos elementos que uma dada lista
	  em ordem reversa.
    (Dica: Use
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>append-to-form</SCHEMEINLINE>.)
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>append_to_form</JAVASCRIPTINLINE>.)
      </JAVASCRIPT>
    </SPLITINLINE>
    Suas regras podem responder tanto
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(reverse (1 2 3) ?x)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>a consulta
	<JAVASCRIPTINLINE>reverse(list(1, 2, 3), $x)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    quanto <SPLITINLINE>
    <SCHEME><SCHEMEINLINE>(reverse ?x (1 2 3))</SCHEMEINLINE>?</SCHEME>
    <JAVASCRIPT>a consulta <JAVASCRIPTINLINE>reverse($x, list(1, 2, 3))</JAVASCRIPTINLINE>?
    </JAVASCRIPT>
    </SPLITINLINE>
    <LABEL NAME="ex:4_66"/>
  </EXERCISE>

  <SPLIT>
    <SCHEME>
      <EXERCISE>
	<LABEL NAME="ex:great-grandson_scheme"/>
	Começando com a base de dados e as regras que você formulou no
	exercício<SPACE/><REF NAME="ex:genesis"/>, crie uma regra para adicionar
	<QUOTE>greats</QUOTE> a uma relação de neto. Isso deve permitir que o
	sistema deduza que Irad é o bisneto de Adão, ou que Jabal
	e Jubal são os tataratataranetos de Adão.
	(Dica: Represente o fato sobre Irad, por exemplo, como
	<SCHEMEINLINE>((great grandson) Adam Irad)</SCHEMEINLINE>.
	Escreva regras que determinem se uma lista termina com a palavra
	<SCHEMEINLINE>grandson</SCHEMEINLINE>.
	Use isso para expressar uma regra que permita derivar a relação
	<SCHEMEINLINE>((great .  ?rel) ?x ?y)</SCHEMEINLINE>,
	onde <SCHEMEINLINE>?rel</SCHEMEINLINE> é uma lista que termina em
	<SCHEMEINLINE>grandson</SCHEMEINLINE>.) Verifique suas regras em consultas como
	<SCHEMEINLINE>((great grandson) ?g ?ggs)</SCHEMEINLINE> e
	<SCHEMEINLINE>(?relationship Adam Irad)</SCHEMEINLINE>.
      </EXERCISE>
    </SCHEME>
    <JAVASCRIPT>
      <EXERCISE>
	<LABEL NAME="ex:great-grandson"/>
	Vamos modificar a base de dados e as regras do
	exercício<SPACE/><REF NAME="ex:genesis"/> para adicionar
	<QUOTE>great</QUOTE> a uma relação de neto. Isso deve permitir que o
	sistema deduza que Irad é o bisneto de Adão, ou que Jabal
	e Jubal são os tataratataranetos de Adão.
	<OL>
	  <LI>
	    Altere as asserções na base de dados de modo que haja apenas um
	    tipo de informação de relacionamento, ou seja,
	    <JAVASCRIPTINLINE>related</JAVASCRIPTINLINE>. O primeiro item
	    então descreve o relacionamento. Assim, em vez de
	    <JAVASCRIPTINLINE>son("Adam", "Cain")</JAVASCRIPTINLINE>, você escreveria
	    <JAVASCRIPTINLINE>related("son", "Adam", "Cain")</JAVASCRIPTINLINE>.
	    Represente o fato sobre Irad, por exemplo, como
	    <SNIPPET EVAL="no">
	      <JAVASCRIPT>
related(list("great", "grandson"), "Adam", "Irad")
	      </JAVASCRIPT>
	    </SNIPPET>
	  </LI>
	  <LI>
	    Escreva regras que determinem se uma lista termina com a palavra
	    <JAVASCRIPTINLINE>"grandson"</JAVASCRIPTINLINE>.
	  </LI>
	  <LI>
	    Use isso para expressar uma regra que permita derivar o relacionamento
	    <SNIPPET EVAL="no">
	      <JAVASCRIPT>
list(pair("great", $rel), $x, $y)
	      </JAVASCRIPT>
	    </SNIPPET>
	    onde <JAVASCRIPTINLINE>$rel</JAVASCRIPTINLINE> é uma lista que termina em
	    <JAVASCRIPTINLINE>"grandson"</JAVASCRIPTINLINE>.
	  </LI>
	  <LI>
	    Verifique suas regras nas consultas
	    <JAVASCRIPTINLINE>related(list("great", "grandson"), $g, $ggs)</JAVASCRIPTINLINE>
	    e
	    <JAVASCRIPTINLINE>related($relationship, "Adam", "Irad")</JAVASCRIPTINLINE>.
	  </LI>
	</OL>
	<COMMENT>
	  Este exercício é um pouco mais verboso do que o original, devido à
	  escolha de usar símbolos de predicado explícitos em vez de listas gerais,
	  veja comentário no início da seção 4.4.1. Então a dica aqui é
	  reverter para uma representação de lista que torna o relacionamento
	  explícito e, portanto, programável. Este truque é usado na
	  implementação do HiLog, uma linguagem de programação lógica com predicados de primeira classe,
	  veja
	  Chen, Weidong; Kifer, Michael; Warren, David S.
	  (Fevereiro de 1993). <QUOTE>HiLog: A Foundation for Higher-Order Logic
	  Programming</QUOTE>. <EM>Journal of Logic Programming</EM>. <B>15</B>
	  (3): 187<ENDASH/>230.
	</COMMENT>
      </EXERCISE>
    </JAVASCRIPT>
  </SPLIT>

  <INDEX>query language<SUBINDEX>mathematical logic vs.<CLOSE/></SUBINDEX></INDEX>
  <INDEX>logic programming<SUBINDEX>mathematical logic vs.<CLOSE/></SUBINDEX></INDEX>

</SUBSECTION>
