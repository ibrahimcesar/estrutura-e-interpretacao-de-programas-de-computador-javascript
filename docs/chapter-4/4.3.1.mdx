<SUBSECTION>
  <NAME>
    <SPLITINLINE>
      <SCHEME>Amb and Search</SCHEME>
      <JAVASCRIPT>Busca e <JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
  </NAME>

  <LABEL NAME="sec:amb"/>

  <TEXT>
    Para estender o
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    para suportar não determinismo, introduzimos uma nova
    <SPLITINLINE>
      <SCHEME>special form</SCHEME>
      <JAVASCRIPT>forma sintática</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX><DECLARATION>amb</DECLARATION></INDEX>
    chamada<SPACE/><SCHEMEINLINE>amb</SCHEMEINLINE>.<FOOTNOTE>A ideia de
    <SCHEMEINLINE>amb</SCHEMEINLINE> para programação não determinística foi
    descrita pela primeira vez em 1961 por
    <INDEX>McCarthy, John</INDEX>
    John McCarthy (veja
    <CITATION>McCarthy 1967</CITATION>).</FOOTNOTE>
    A expressão
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>(amb </SCHEMEINLINE><LATEXINLINE>$e_1\ e_2\ldots e_n$</LATEXINLINE><SCHEMEINLINE>)</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>amb(</JAVASCRIPTINLINE><LATEXINLINE>$e_1,\ e_2,\ldots, e_n$</LATEXINLINE><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    retorna o valor de uma das <LATEXINLINE>$n$</LATEXINLINE> expressões
    <LATEXINLINE>$e_i$</LATEXINLINE> <QUOTE>ambiguamente.</QUOTE> Por exemplo,
    a expressão
    <SNIPPET CHAP="3" VARIANT="non-det">
      <NAME>list_non_det</NAME>
      <SCHEME>
(list (amb 1 2 3) (amb 'a 'b))
      </SCHEME>
      <JAVASCRIPT>
list(amb(1, 2, 3), amb("a", "b"));
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
list(amb(1, 2, 3), amb("a", "b"));
// Pressione "Run" para a primeira solução. Digite
// retry
// no REPL à direita, para mais soluções
      </JAVASCRIPT_RUN>
    </SNIPPET>
    pode ter seis valores possíveis:
    <SNIPPET EVAL="no">
      <SCHEME>
(1 a) (1 b) (2 a) (2 b) (3 a) (3 b)
      </SCHEME>
      <JAVASCRIPT>
list(1, "a") list(1, "b") list(2, "a")
list(2, "b") list(3, "a") list(3, "b")
      </JAVASCRIPT>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Amb</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	Uma expressão <JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    com uma única escolha produz um valor comum (único).
  </TEXT>
  <LONG_PAGE lines="1"/>
  <TEXT>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>Amb</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	Uma expressão <JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    sem escolhas<EMDASH/>a expressão
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(amb)</SCHEMEINLINE><EMDASH/>é</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>amb()</JAVASCRIPTINLINE><EMDASH/>é
      </JAVASCRIPT>
    </SPLITINLINE>
    <INDEX>failure, in nondeterministic computation</INDEX>
    uma expressão sem valores aceitáveis. Operacionalmente, podemos pensar em
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(amb)</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>amb()</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    como uma expressão que quando avaliada faz a computação
    <QUOTE>falhar</QUOTE>: A computação é abortada e nenhum valor é produzido.
    Usando esta ideia, podemos expressar o requisito de que uma expressão
    predicado particular <SCHEMEINLINE>p</SCHEMEINLINE> deve ser verdadeira da seguinte forma:
    <SNIPPET HIDE="yes">
      <NAME>require_non_det_example</NAME>
      <JAVASCRIPT>
const x = amb(1, 3, 5, 7, 9);
require(x &gt;= 4);
x;
// Pressione "Run" para a primeira solução. Digite
// retry
// no REPL à direita, para mais soluções
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="3" VARIANT="non-det">
      <INDEX><DECLARATION>require</DECLARATION></INDEX>
      <NAME>require_non_det</NAME>
      <EXAMPLE>require_non_det_example</EXAMPLE>
      <EXPECTED>5</EXPECTED>
      <SCHEME>
(define (require p)
  (if (not p) (amb)))
      </SCHEME>
      <JAVASCRIPT>
function require(p) {
    if (! p) {
        amb();
    } else {}
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Com <SCHEMEINLINE>amb</SCHEMEINLINE> e
    <SCHEMEINLINE>require</SCHEMEINLINE>, podemos implementar a
    <SPLITINLINE>
      <SCHEME>procedure <SCHEMEINLINE>an-element-of</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>função <JAVASCRIPTINLINE>an_element_of</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    usada acima:
    <SNIPPET HIDE="yes">
      <NAME>an_element_of_example</NAME>
      <JAVASCRIPT>
const xs = list("apple", "banana", "cranberry");
an_element_of(xs);
// Pressione "Run" para a primeira solução. Digite
// retry
// no REPL à direita, para mais soluções
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="3" VARIANT="non-det">
      <INDEX><DECLARATION>an_element_of</DECLARATION></INDEX>
      <NAME>an_element_of</NAME>
      <EXAMPLE>an_element_of_example</EXAMPLE>
      <EXPECTED>'apple'</EXPECTED>
      <SCHEME>
(define (an-element-of items)
  (require (not (null? items)))
  (amb (car items) (an-element-of (cdr items))))
      </SCHEME>
      <JAVASCRIPT>
function an_element_of(items) {
    require(! is_null(items));
    return amb(head(items), an_element_of(tail(items)));
}
      </JAVASCRIPT>
    </SNIPPET>
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>An-element-of</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	Uma aplicação de <JAVASCRIPTINLINE>an_element_of</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    falha se a lista está vazia. Caso contrário, ela retorna ambiguamente ou o
    primeiro elemento da lista ou um elemento escolhido do resto da lista.
  </TEXT>

  <TEXT>
    Também podemos expressar intervalos infinitos de escolhas. A seguinte
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    potencialmente retorna qualquer inteiro maior ou igual a algum
    <LATEXINLINE>$n$</LATEXINLINE> dado:
    <SNIPPET HIDE="yes">
      <NAME>an_integer_starting_from_example</NAME>
      <JAVASCRIPT>
const x = an_integer_starting_from(1);
require(x >= 4.5);
x;
// Pressione "Run" para a primeira solução. Digite
// retry
// no REPL à direita, para mais soluções
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="3" VARIANT="non-det">
      <INDEX><DECLARATION>an_integer_starting_from</DECLARATION></INDEX>
      <NAME>an_integer_starting_from</NAME>
      <EXAMPLE>an_integer_starting_from_example</EXAMPLE>
      <EXPECTED>5</EXPECTED>
      <SCHEME>
(define (an-integer-starting-from n)
  (amb n (an-integer-starting-from (+ n 1))))
      </SCHEME>
      <JAVASCRIPT>
function an_integer_starting_from(n) {
    return amb(n, an_integer_starting_from(n + 1));
}
      </JAVASCRIPT>
    </SNIPPET>
    Isto é como a
    <SPLITINLINE>
      <SCHEME>procedure
      <SCHEMEINLINE>integers-starting-from</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>função
      <JAVASCRIPTINLINE>integers_starting_from</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    de streams descrita na seção <REF NAME="sec:infinite-streams"/>, mas com uma
    diferença importante: A
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    de stream retorna um objeto que representa a sequência de todos os inteiros começando
    com <LATEXINLINE>$n$</LATEXINLINE>, enquanto a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>amb</SCHEMEINLINE>
    retorna um único inteiro.<FOOTNOTE>Na realidade, a distinção entre
    retornar não deterministicamente uma única escolha e retornar todas as escolhas
    depende um pouco do nosso ponto de vista. Da perspectiva do código
    que usa o valor, a escolha não determinística retorna um valor único.
    Da perspectiva do programador projetando o código, a
    escolha não determinística potencialmente retorna todos os valores possíveis, e a
    computação se ramifica de modo que cada valor seja investigado
    separadamente.</FOOTNOTE>
  </TEXT>

  <LONG_PAGE lines="2"/>
  <TEXT>
    Abstratamente, podemos imaginar que avaliar uma
    expressão <SCHEMEINLINE>amb</SCHEMEINLINE> faz com que
    <INDEX>time<SUBINDEX>in nondeterministic computing</SUBINDEX></INDEX>
    o tempo se divida em
    ramificações, onde a computação continua em cada ramificação com um dos
    valores possíveis da expressão. Dizemos que
    <SCHEMEINLINE>amb</SCHEMEINLINE> representa um
    <INDEX>nondeterministic choice point</INDEX>
    <EM>ponto de escolha não determinístico</EM>. Se tivéssemos uma máquina com um
    número suficiente de processadores que pudessem ser alocados dinamicamente, poderíamos
    implementar a busca de uma maneira direta. A execução prosseguiria
    como em uma máquina sequencial, até que uma expressão <SCHEMEINLINE>amb</SCHEMEINLINE>
    fosse encontrada. Neste ponto, mais processadores seriam alocados
    e inicializados para continuar todas as execuções paralelas implicadas pela
    escolha. Cada processador prosseguiria sequencialmente como se fosse a única
    escolha, até que ou terminasse encontrando uma falha, ou subdividisse ainda mais,
    ou terminasse.<FOOTNOTE>Pode-se objetar que este é um
    mecanismo absurdamente ineficiente. Poderia exigir milhões de processadores
    para resolver algum problema facilmente formulado desta forma, e na maior parte do tempo a maioria
    desses processadores estaria ociosa. Esta objeção deve ser tomada no
    contexto da história. A memória costumava ser considerada justamente uma
    mercadoria cara.
    <INDEX>memory<SUBINDEX>in 1965</SUBINDEX></INDEX>
    Em 1965, um megabyte de RAM custava cerca de <DOLLAR/>400.000. Agora todo computador pessoal
    tem muitos gigabytes de RAM, e na maior parte do tempo a maior parte dessa RAM está
    sem uso. É difícil subestimar o custo da eletrônica
    produzida em massa.</FOOTNOTE>
  </TEXT>

  <TEXT>
    Por outro lado, se tivermos uma máquina que pode executar apenas um processo
    (ou poucos processos concorrentes), devemos considerar as alternativas
    <INDEX>failure, in nondeterministic computation<SUBINDEX>searching and</SUBINDEX></INDEX>
    sequencialmente. Pode-se imaginar modificar um avaliador para escolher aleatoriamente uma
    ramificação para seguir sempre que encontrar um ponto de escolha. A escolha aleatória,
    no entanto, pode facilmente levar a valores que falham. Poderíamos tentar executar o
    avaliador repetidamente, fazendo escolhas aleatórias e esperando encontrar um
    valor sem falha, mas é melhor
    <INDEX>systematic search</INDEX>
    <INDEX>search<SUBINDEX>systematic</SUBINDEX></INDEX>
    <EM>buscar sistematicamente</EM> todos os caminhos de execução possíveis. O
    avaliador <SCHEMEINLINE>amb</SCHEMEINLINE> que desenvolveremos e trabalharemos
    com nesta seção implementa uma busca sistemática da seguinte forma: Quando o
    avaliador encontra uma aplicação de <SCHEMEINLINE>amb</SCHEMEINLINE>, ele
    inicialmente seleciona a primeira alternativa. Esta seleção pode em si levar a
    uma escolha adicional. O avaliador sempre escolherá inicialmente a primeira
    alternativa em cada ponto de escolha. Se uma escolha resultar em uma falha, então
    o avaliador
    <INDEX>automagically</INDEX>
    automagicamente<FOOTNOTE>Automagicamente: <QUOTE>Automaticamente, mas de uma maneira
    que, por alguma razão (tipicamente porque é muito complicado, ou muito feio,
    ou talvez até muito trivial), o falante não se sente à vontade para
    explicar.</QUOTE>
    <INDEX>Steele, Guy Lewis Jr.</INDEX>
    (<CITATION>Steele 1983</CITATION>,
    <INDEX>Raymond, Eric</INDEX>
    <CITATION>Raymond 1996</CITATION>)</FOOTNOTE>
    <INDEX>backtracking</INDEX>
    <EM>retrocede (backtrack)</EM> ao ponto de escolha mais recente e tenta a próxima
    alternativa. Se ele esgotar as alternativas em qualquer ponto de escolha, o
    avaliador voltará ao ponto de escolha anterior e retomará de lá.
    Este processo leva a uma estratégia de busca conhecida como
    <INDEX>depth-first search</INDEX>
    <INDEX>search<SUBINDEX>depth-first</SUBINDEX></INDEX>
    <EM>busca em profundidade</EM> ou
    <INDEX>chronological backtracking</INDEX>
    <EM>backtracking
    cronológico</EM>.<FOOTNOTE>A integração de
    <INDEX>automatic search<SUBINDEX>history of</SUBINDEX></INDEX>
    estratégias de busca automática
    em linguagens de programação tem uma longa e acidentada história. As primeiras
    sugestões de que algoritmos não determinísticos poderiam ser elegantemente codificados em uma
    linguagem de programação com busca e backtracking automático vieram de
    <INDEX>Floyd, Robert</INDEX>
    Robert Floyd (1967).
    <INDEX>Hewitt, Carl Eddie</INDEX>
    Carl Hewitt (1969) inventou uma linguagem de programação chamada
    <INDEX>Planner</INDEX>
    Planner que explicitamente suportava backtracking cronológico automático,
    fornecendo uma estratégia de busca em profundidade integrada.
    <INDEX>Sussman, Gerald Jay</INDEX>
    <INDEX>Winograd, Terry</INDEX>
    <INDEX>Charniak, Eugene</INDEX>
    Sussman, Winograd e Charniak (1971) implementaram um subconjunto desta linguagem,
    chamado
    <INDEX>MicroPlanner</INDEX>
    MicroPlanner, que foi usado para suportar trabalho em resolução de problemas e
    planejamento de robôs. Ideias similares, surgindo da lógica e prova de teoremas, levaram à
    gênese em Edimburgo e Marselha da elegante linguagem
    <INDEX>Prolog</INDEX>
    Prolog (que discutiremos na
    seção<SPACE/><REF NAME="sec:logic-programming"/>). Após suficiente
    frustração com busca automática,
    <INDEX>McDermott, Drew</INDEX>
    <INDEX>Sussman, Gerald Jay</INDEX>
    McDermott e Sussman (1972) desenvolveram uma linguagem chamada
    <INDEX>Conniver</INDEX>
    Conniver, que incluía mecanismos para colocar a estratégia de busca sob
    controle do programador. Isso se provou difícil de manejar, no entanto, e
    <INDEX>Sussman, Gerald Jay</INDEX>
    <INDEX>Stallman, Richard M.</INDEX>
    Sussman e Stallman (1975) encontraram uma abordagem mais tratável enquanto
    investigavam métodos de análise simbólica para circuitos elétricos. Eles
    desenvolveram um esquema de backtracking não cronológico que era baseado em rastrear
    as dependências lógicas conectando fatos, uma técnica que veio a
    ser conhecida como
    <INDEX>dependency-directed backtracking</INDEX>
    <EM>backtracking direcionado por dependências</EM>. Embora seu método fosse
    complexo, ele produzia programas razoavelmente eficientes porque fazia pouca
    busca redundante.
    <INDEX>Doyle, Jon</INDEX>
    <CITATION>Doyle (1979)</CITATION> e
    <INDEX>McAllester, David Allen</INDEX>
    <CITATION>McAllester (1978, 1980)</CITATION>
    generalizaram e esclareceram os métodos de Stallman e Sussman, desenvolvendo um
    novo paradigma para formular busca que agora é chamado
    <INDEX>truth maintenance</INDEX>
    <EM>manutenção de verdade</EM>.
    <SPLITINLINE>
      <SCHEME>
	Todos os sistemas modernos de resolução de problemas
      </SCHEME>
      <JAVASCRIPT>
	Muitos sistemas de resolução de problemas
      </JAVASCRIPT>
    </SPLITINLINE>
    usam alguma forma de sistema de manutenção de verdade como substrato. Veja
    <INDEX>Forbus, Kenneth D.</INDEX>
    <INDEX>de Kleer, Johan</INDEX>
    <CITATION>Forbus and de Kleer 1993</CITATION> para uma discussão de maneiras elegantes
    de construir sistemas de manutenção de verdade e aplicações usando manutenção de
    verdade.
    <INDEX>Zabih, Ramin</INDEX>
    <INDEX>McAllester, David Allen</INDEX>
    <INDEX>Chapman, David</INDEX>
    <CITATION>Zabih, McAllester, and Chapman 1987</CITATION> descreve uma
    <INDEX>Scheme<SUBINDEX>nondeterministic extension of</SUBINDEX></INDEX>
    extensão não determinística do Scheme que é baseada em
    <SCHEMEINLINE>amb</SCHEMEINLINE>; ela é similar ao interpretador descrito
    nesta seção, mas mais sofisticada, porque usa backtracking direcionado por dependências
    em vez de backtracking cronológico.
    <INDEX>Winston, Patrick Henry</INDEX>
    <CITATION>Winston 1992</CITATION> dá uma introdução a
    ambos os tipos de backtracking.<LABEL NAME="foot:backtrack"/></FOOTNOTE>
  </TEXT>

  <DO_BREAK_PAGE/>
  <SUBHEADING>
    <NAME>Driver loop</NAME>
  </SUBHEADING>

  <TEXT>
    O
    <INDEX>driver loop<SUBINDEX><ORDER>nondeterministic</ORDER>in nondeterministic evaluator</SUBINDEX></INDEX>
    loop de driver para o avaliador <SCHEMEINLINE>amb</SCHEMEINLINE> tem algumas
    propriedades incomuns. Ele lê
    <SPLITINLINE>
      <SCHEME>uma expressão</SCHEME>
      <JAVASCRIPT>um programa</JAVASCRIPT>
    </SPLITINLINE>
    e imprime o valor da
    primeira execução sem falha, como no exemplo
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>prime-sum-pair</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>prime_sum_pair</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    mostrado acima. Se quisermos ver o valor da próxima execução bem-sucedida,
    podemos pedir ao interpretador para retroceder e tentar gerar uma
    segunda execução sem falha.
    <SPLIT>
      <SCHEME>
	Isso é sinalizado digitando o símbolo
	<INDEX><DECLARATION>try-again</DECLARATION></INDEX>
	<SCHEMEINLINE>try-again</SCHEMEINLINE>. Se qualquer expressão exceto
	<SCHEMEINLINE>try-again</SCHEMEINLINE>
	for fornecida, o interpretador iniciará um novo problema, descartando as
	alternativas não exploradas no problema anterior.
      </SCHEME>
      <JAVASCRIPT>
	Isso é sinalizado digitando
	<INDEX><DECLARATION>retry</DECLARATION></INDEX>
	<JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>.
	Se qualquer outra entrada exceto <JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
	for fornecida, o interpretador iniciará um novo problema, descartando as
	alternativas não exploradas no problema anterior.
      </JAVASCRIPT>
    </SPLIT>
    Aqui está um exemplo de interação:
    <SNIPPET CHAP="3" VARIANT="non-det">
      <NAME>interaction_non_det</NAME>
      <REQUIRES>is_prime2</REQUIRES>
      <REQUIRES>prime_sum_pair_non_det</REQUIRES>
      <SCHEMEPROMPT>
;;; Amb-Eval input:
      </SCHEMEPROMPT>
      <SCHEME>
(prime-sum-pair '(1 3 5 8) '(20 35 110))
      </SCHEME>
      <SCHEMEOUTPUT>
;;; Starting a new problem
;;; Amb-Eval value:
(3 20)
      </SCHEMEOUTPUT>
      <JAVASCRIPT_PROMPT>
amb-evaluate input:
      </JAVASCRIPT_PROMPT>
      <JAVASCRIPT>
prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
Iniciando um novo problema
amb-evaluate value:
[3, [20, null]]
      </JAVASCRIPT_OUTPUT>
      <JAVASCRIPT_RUN>
prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));
// Pressione "Run" para a primeira solução. Digite
// retry
// no REPL à direita, para mais soluções
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET CHAP="3" VARIANT="non-det">
      <NAME>interaction_non_det_2</NAME>
      <REQUIRES>is_prime2</REQUIRES>
      <REQUIRES>prime_sum_pair_non_det</REQUIRES>
      <SCHEMEPROMPT>
;;; Amb-Eval input:
      </SCHEMEPROMPT>
      <SCHEME>
try-again
      </SCHEME>
      <SCHEMEOUTPUT>
;;; Amb-Eval value:
(3 110)
      </SCHEMEOUTPUT>
      <JAVASCRIPT_PROMPT>
amb-evaluate input:
      </JAVASCRIPT_PROMPT>
      <JAVASCRIPT>
retry
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
amb-evaluate value:
[3, [110, null]]
      </JAVASCRIPT_OUTPUT>
      <JAVASCRIPT_RUN>
prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));
// Pressione "Run" para a primeira solução. Digite
// retry
// no REPL à direita, para mais soluções
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET CHAP="3" VARIANT="non-det">
      <NAME>interaction_non_det_3</NAME>
      <REQUIRES>is_prime2</REQUIRES>
      <REQUIRES>prime_sum_pair_non_det</REQUIRES>
      <SCHEMEPROMPT>
;;; Amb-Eval input:
      </SCHEMEPROMPT>
      <SCHEME>
try-again
      </SCHEME>
      <SCHEMEOUTPUT>
;;; Amb-Eval value:
(8 35)

;;; Amb-Eval input:
      </SCHEMEOUTPUT>
      <JAVASCRIPT_PROMPT>
amb-evaluate input:
      </JAVASCRIPT_PROMPT>
      <JAVASCRIPT>
retry
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
amb-evaluate value:
[8, [35, null]]
      </JAVASCRIPT_OUTPUT>
      <JAVASCRIPT_RUN>
prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));
// Pressione "Run" para a primeira solução. Digite
// retry
// no REPL à direita, para mais soluções
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET CHAP="3" VARIANT="non-det">
      <NAME>interaction_non_det_4</NAME>
      <REQUIRES>is_prime2</REQUIRES>
      <REQUIRES>prime_sum_pair_non_det</REQUIRES>
      <SCHEME>
try-again
      </SCHEME>
      <SCHEMEOUTPUT>
;;; There are no more values of
(prime-sum-pair (quote (1 3 5 8)) (quote (20 35 110)))
      </SCHEMEOUTPUT>
      <JAVASCRIPT_PROMPT>
amb-evaluate input:
      </JAVASCRIPT_PROMPT>
      <JAVASCRIPT>
retry
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
Não há mais valores de
prime_sum_pair([1, [3, [5, [8, null]]]], [20, [35, [110, null]]])
      </JAVASCRIPT_OUTPUT>
      <JAVASCRIPT_RUN>
prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));
// Pressione "Run" para a primeira solução. Digite
// retry
// no REPL à direita, para mais soluções
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET CHAP="3" VARIANT="non-det" POSTPADDING="no">
      <NAME>interaction_non_det_5</NAME>
      <REQUIRES>is_prime2</REQUIRES>
      <REQUIRES>prime_sum_pair_non_det</REQUIRES>
      <SCHEMEPROMPT>
;;; Amb-Eval input:
      </SCHEMEPROMPT>
      <SCHEME>
(prime-sum-pair '(19 27 30) '(11 36 58))
      </SCHEME>
      <SCHEMEOUTPUT>
;;; Starting a new problem
;;; Amb-Eval value:
(30 11)
      </SCHEMEOUTPUT>
      <JAVASCRIPT_PROMPT>
amb-evaluate input:
      </JAVASCRIPT_PROMPT>
      <JAVASCRIPT>
prime_sum_pair(list(19, 27, 30), list(11, 36, 58));
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
Iniciando um novo problema
amb-evaluate value:
[30, [11, null]]
      </JAVASCRIPT_OUTPUT>
      <JAVASCRIPT_RUN>
prime_sum_pair(list(19, 27, 30), list(11, 36, 58));
// Pressione "Run" para a primeira solução. Digite
// retry
// no REPL à direita, para mais soluções
      </JAVASCRIPT_RUN>
    </SNIPPET>
  </TEXT>

  <EXERCISE>
    <LABEL NAME="ex:amb-pythag-triples"/>
    Escreva uma
    <SPLITINLINE>
      <SCHEME>procedure
      <SCHEMEINLINE>an-integer-between</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>função
      <JAVASCRIPTINLINE>an_integer_between</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    que retorna um inteiro entre dois limites dados. Isso pode ser usado para
    implementar uma
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    que encontra
    <INDEX>Pythagorean triples<SUBINDEX>with nondeterministic programs</SUBINDEX></INDEX>
    <INDEX>nondeterministic programs<SUBINDEX>Pythagorean triples</SUBINDEX></INDEX>
    triplas pitagóricas, isto é, triplas de inteiros
    <LATEXINLINE>$(i,j,k)$</LATEXINLINE> entre os limites dados tal
    que <LATEXINLINE>$i \leq j$</LATEXINLINE> e
    <LATEXINLINE>$i^2 + j^2 =k^2$</LATEXINLINE>, da seguinte forma:
    <SNIPPET HIDE="yes">
      <NAME>pythagorean_triple_amb_example</NAME>
      <JAVASCRIPT>
a_pythogorean_triple_between(5, 15);
// Pressione "Run" para a primeira solução. Digite
// retry
// no REPL à direita, para mais soluções
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="3" VARIANT="non-det" POSTPADDING="no">
      <NAME>pythagorean_triple_amb</NAME>
      <EXAMPLE>pythagorean_triple_amb_example</EXAMPLE>
      <EXPECTED>[ 5, [ 12, [ 13, null] ] ]</EXPECTED>
      <SCHEME>
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high)))
    (let ((j (an-integer-between i high)))
      (let ((k (an-integer-between j high)))
        (require (= (+ (* i i) (* j j)) (* k k)))
        (list i j k)))))
      </SCHEME>
      <JAVASCRIPT>
function a_pythogorean_triple_between(low, high) {
    const i = an_integer_between(low, high);
    const j = an_integer_between(i, high);
    const k = an_integer_between(j, high);
    require(i * i + j * j === k * k);
    return list(i, j, k);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SOLUTION>
      <SNIPPET>
	<JAVASCRIPT>
// solução do usuário do GitHub jonathantorres

function an_integer_between(low, high) {
    require(low &lt;= high);
    return amb(low, an_integer_between(low+1, high));
}
	</JAVASCRIPT>
      </SNIPPET>
    </SOLUTION>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:amb-pythag-triples_2"/>
    O exercício<SPACE/><REF NAME="ex:stream-pythagorean-triples"/> discutiu como
    gerar o stream de <EM>todas</EM> as
    <INDEX>Pythagorean triples<SUBINDEX>with nondeterministic programs</SUBINDEX></INDEX>
    <INDEX>nondeterministic programs<SUBINDEX>Pythagorean triples</SUBINDEX></INDEX>
    triplas pitagóricas, sem limite superior
    no tamanho dos inteiros a serem pesquisados. Explique por que simplesmente substituir
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>an-integer-between</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>an_integer_between</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    por
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>an-integer-starting-from</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>an_integer_starting_from</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    na
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    do
    exercício<SPACE/><REF NAME="ex:amb-pythag-triples"/> não é uma maneira adequada de
    gerar triplas pitagóricas arbitrárias. Escreva uma
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    que realmente conseguirá isso. (Isto é, escreva uma
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    para a qual digitar repetidamente
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>try-again</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    em princípio eventualmente geraria todas as triplas pitagóricas.)
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:amb-pythag-triples_3"/>
    Ben Bitdiddle afirma que o seguinte método para gerar
    <INDEX>Pythagorean triples<SUBINDEX>with nondeterministic programs</SUBINDEX></INDEX>
    <INDEX>nondeterministic programs<SUBINDEX>Pythagorean triples</SUBINDEX></INDEX>
    triplas
    pitagóricas é mais eficiente que o do
    exercício<SPACE/><REF NAME="ex:amb-pythag-triples"/>. Ele está correto?
    (Dica: Considere o número de possibilidades que devem ser exploradas.)
    <SNIPPET HIDE="yes">
      <NAME>a_pythagorean_triple_between_2_example</NAME>
      <JAVASCRIPT>
function is_integer(x) {
    return x === math_floor(x);
}
a_pythagorean_triple_between(5, 15);
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET CHAP="3" VARIANT="non-det" POSTPADDING="no">
      <NAME>a_pythagorean_triple_between_2</NAME>
      <EXAMPLE>a_pythagorean_triple_between_2_example</EXAMPLE>
      <SCHEME>
(define (a-pythagorean-triple-between low high)
  (let ((i (an-integer-between low high))
        (hsq (* high high)))
    (let ((j (an-integer-between i high)))
      (let ((ksq (+ (* i i) (* j j))))
        (require (&gt;= hsq ksq))
        (let ((k (sqrt ksq)))
          (require (integer? k))
          (list i j k))))))
      </SCHEME>
      <JAVASCRIPT>
function a_pythagorean_triple_between(low, high) {
    const i = an_integer_between(low, high);
    const hsq = high * high;
    const j = an_integer_between(i, high);
    const ksq = i * i + j * j;
    require(hsq &gt;= ksq);
    const k = math_sqrt(ksq);
    require(is_integer(k));
    return list(i, j, k);
}
      </JAVASCRIPT>
    </SNIPPET>
  </EXERCISE>
</SUBSECTION>
