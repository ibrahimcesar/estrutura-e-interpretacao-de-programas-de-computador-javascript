<SUBSECTION>
  <NAME>
    Implementando o Avaliador
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>Amb</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
  </NAME>

  <LABEL NAME="sec:amb-implementation"/>

  <INDEX>nondeterministic evaluator<OPEN/></INDEX>

  <TEXT>
    A avaliação de uma
    <SPLITINLINE>
      <SCHEME>expressão Scheme</SCHEME>
      <JAVASCRIPT>programa JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    comum pode retornar um valor, pode nunca terminar, ou pode sinalizar um erro.
    Em
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    não determinístico, a avaliação de
    <SPLITINLINE>
      <SCHEME>uma expressão</SCHEME>
      <JAVASCRIPT>um programa</JAVASCRIPT>
    </SPLITINLINE>
    pode adicionalmente resultar na descoberta de
    um beco sem saída, caso em que a avaliação deve retroceder para um ponto de escolha
    anterior. A interpretação de
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    não determinístico é complicada por este caso extra.
  </TEXT>

  <TEXT>
    Construiremos o avaliador <SCHEMEINLINE>amb</SCHEMEINLINE> para
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    não determinístico modificando o
    <INDEX>analyzing evaluator<SUBINDEX>as basis for nondeterministic evaluator</SUBINDEX></INDEX>
    avaliador analisador da
    seção<SPACE/><REF NAME="sec:separating-analysis"/>.<FOOTNOTE>Escolhemos
    implementar o avaliador preguiçoso na
    seção<SPACE/><REF NAME="sec:lazy-evaluation"/> como uma modificação do
    avaliador metacircular comum da
    seção<SPACE/><REF NAME="sec:core-of-evaluator"/>. Em contraste,
    basearemos o avaliador <SCHEMEINLINE>amb</SCHEMEINLINE> no avaliador
    analisador da seção<SPACE/><REF NAME="sec:separating-analysis"/>, porque
    as
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>funções</JAVASCRIPT>
    </SPLITINLINE>
    de execução naquele avaliador fornecem uma estrutura conveniente para implementar
    backtracking.</FOOTNOTE> Como no avaliador analisador, a avaliação de
    <SPLITINLINE>
      <SCHEME>uma expressão</SCHEME>
      <JAVASCRIPT>um componente</JAVASCRIPT>
    </SPLITINLINE>
    é realizada chamando uma
    <INDEX>execution<SPLITINLINE> <SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>in nondeterministic evaluator</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    de execução produzida pela análise daquele
    <SPLITINLINE>
      <SCHEME>expression.</SCHEME>
      <JAVASCRIPT>componente.</JAVASCRIPT>
    </SPLITINLINE>
    A diferença entre a interpretação de
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    comum e a interpretação de
    <SPLITINLINE>
      <SCHEME>Scheme</SCHEME>
      <JAVASCRIPT>JavaScript</JAVASCRIPT>
    </SPLITINLINE>
    não determinístico estará inteiramente
    nas
    <SPLITINLINE>
      <SCHEME>procedures.</SCHEME>
      <JAVASCRIPT>funções</JAVASCRIPT>
    </SPLITINLINE>
    de execução.
  </TEXT>

  <SUBHEADING>
    <NAME>
      <SPLITINLINE>
	<SCHEME>Procedures</SCHEME>
	<JAVASCRIPT>Funções</JAVASCRIPT>
      </SPLITINLINE>
      de execução e continuações
    </NAME>
  </SUBHEADING>

  <INDEX>continuation<SUBINDEX>in nondeterministic evaluator<OPEN/></SUBINDEX></INDEX>

  <TEXT>
    Lembre-se de que as
    <INDEX>execution <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>in nondeterministic evaluator</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>funções</JAVASCRIPT>
    </SPLITINLINE>
    de execução para o avaliador comum recebem um argumento: o ambiente de execução.
    Em contraste, as
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>funções</JAVASCRIPT>
    </SPLITINLINE>
    de execução no avaliador <SCHEMEINLINE>amb</SCHEMEINLINE> recebem três argumentos:
    o ambiente e duas
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>funções</JAVASCRIPT>
    </SPLITINLINE>
    chamadas
    <SPLITINLINE>
      <SCHEME><EM>procedures de continuação</EM>.</SCHEME>
      <JAVASCRIPT><EM>funções de continuação</EM>.</JAVASCRIPT>
    </SPLITINLINE>
    A avaliação de
    <SPLITINLINE>
      <SCHEME>uma expressão</SCHEME>
      <JAVASCRIPT>um componente</JAVASCRIPT>
    </SPLITINLINE>
    terminará chamando uma destas duas
    continuações: Se a avaliação resulta em um valor, a
    <INDEX>success continuation (nondeterministic evaluator)</INDEX>
    <EM>continuação de sucesso</EM> é chamada com aquele valor; se a avaliação
    resulta na descoberta de um beco sem saída, a
    <INDEX>failure continuation (nondeterministic evaluator)</INDEX>
    <EM>continuação de falha</EM> é chamada. Construir e chamar
    continuações apropriadas é o mecanismo pelo qual o avaliador não determinístico
    implementa backtracking.
  </TEXT>

  <TEXT>
    É trabalho da continuação de sucesso receber um valor e prosseguir
    com a computação. Junto com aquele valor, a continuação de sucesso recebe
    outra continuação de falha, que deve ser chamada subsequentemente se
    o uso daquele valor levar a um beco sem saída.
  </TEXT>

  <TEXT>
    É trabalho da continuação de falha tentar outro ramo do
    processo não determinístico. A essência da linguagem não determinística
    está no fato de que
    <SPLITINLINE>
      <SCHEME>expressões</SCHEME>
      <JAVASCRIPT>componentes</JAVASCRIPT>
    </SPLITINLINE>
    podem representar escolhas entre
    alternativas. A avaliação de tal
    <SPLITINLINE>
      <SCHEME>expressão</SCHEME>
      <JAVASCRIPT>componente</JAVASCRIPT>
    </SPLITINLINE>
    deve prosseguir com
    uma das escolhas alternativas indicadas, mesmo que não se saiba
    de antemão quais escolhas levarão a resultados aceitáveis. Para lidar
    com isso, o avaliador escolhe uma das alternativas e passa este
    valor para a continuação de sucesso. Junto com este valor, o
    avaliador constrói e passa adiante uma continuação de falha que pode
    ser chamada depois para escolher uma alternativa diferente.
  </TEXT>

  <SHORT_PAGE lines="4"/>
  <TEXT>
    Uma falha é disparada durante a avaliação (isto é, uma
    continuação de falha é chamada) quando um programa de usuário explicitamente rejeita a
    linha de ataque atual (por exemplo, uma chamada a
    <SCHEMEINLINE>require</SCHEMEINLINE> pode resultar na execução de
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>(amb)</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>amb()</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    uma expressão que sempre
    falha<EMDASH/>veja seção<SPACE/><REF NAME="sec:amb"/>). A continuação
    de falha em mãos naquele ponto fará com que o ponto de escolha mais recente
    escolha outra alternativa. Se não houver mais alternativas a serem
    consideradas naquele ponto de escolha, uma falha em um ponto de escolha
    anterior é disparada, e assim por diante. Continuações de falha também são invocadas
    pelo loop de driver em resposta a um pedido de
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    , para encontrar outro valor do
    <SPLITINLINE>
      <SCHEME>expression.</SCHEME>
      <JAVASCRIPT>programa.</JAVASCRIPT>
    </SPLITINLINE>
  </TEXT>

  <TEXT>
    Além disso, se uma operação de efeito colateral (como atribuição a uma
    variável) ocorrer em um ramo do processo resultante de uma escolha,
    pode ser necessário, quando o processo encontrar um beco sem saída, desfazer o
    efeito colateral antes de fazer uma nova escolha. Isso é realizado
    fazendo com que a operação de efeito colateral produza uma continuação de falha que
    desfaça o efeito colateral e propague a falha.
  </TEXT>

  <TEXT>
    Em resumo, continuações de falha são construídas por
    <UL>
      <LI>
	expressões <SCHEMEINLINE>amb</SCHEMEINLINE><EMDASH/>para fornecer um
	mecanismo para fazer escolhas alternativas se a escolha atual feita pela
	expressão <SCHEMEINLINE>amb</SCHEMEINLINE> levar a um beco sem saída;
      </LI>
      <LI>
	o driver de nível superior<EMDASH/>para fornecer um mecanismo para relatar falha
	quando as escolhas se esgotam;
      </LI>
      <LI>
	atribuições<EMDASH/>para interceptar falhas e desfazer atribuições
	durante o backtracking.
      </LI>
    </UL>
  </TEXT>

  <TEXT>
    Falhas são iniciadas apenas quando um beco sem saída é encontrado. Isso ocorre
    <UL>
      <LI>
	se o programa de usuário executar
	<SPLITINLINE>
	  <SCHEME><SCHEMEINLINE>(amb)</SCHEMEINLINE>;</SCHEME>
	  <JAVASCRIPT><JAVASCRIPTINLINE>amb()</JAVASCRIPTINLINE>;</JAVASCRIPT>
	  </SPLITINLINE>
      </LI>
      <LI>
	se o usuário digitar
	<SPLITINLINE>
	  <SCHEME>
	    <SCHEMEINLINE>try-again</SCHEMEINLINE>
	  </SCHEME>
	  <JAVASCRIPT>
	    <JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
	  </JAVASCRIPT>
	</SPLITINLINE>
	no driver de nível superior.
      </LI>

    </UL>
  </TEXT>

  <TEXT>
    Continuações de falha também são chamadas durante o processamento de uma falha:
    <UL>
      <LI>Quando a continuação de falha criada por uma atribuição termina de
      desfazer um efeito colateral, ela chama a continuação de falha que interceptou,
      para propagar a falha de volta ao ponto de escolha que
      levou a esta atribuição ou ao nível superior.

      </LI>
      <LI>Quando a continuação de falha para um <SCHEMEINLINE>amb</SCHEMEINLINE>
      esgota as escolhas, ela chama a continuação de falha que foi originalmente
      dada ao <SCHEMEINLINE>amb</SCHEMEINLINE>, para propagar a
      falha de volta ao ponto de escolha anterior ou ao nível superior.
      </LI>
    </UL>
  </TEXT>

  <INDEX>continuation<SUBINDEX>in nondeterministic evaluator<CLOSE/></SUBINDEX></INDEX>

  <SUBHEADING>
    <NAME>Estrutura do avaliador</NAME>
  </SUBHEADING>

  <TEXT>
    As
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>funções</JAVASCRIPT>
    </SPLITINLINE>
    de sintaxe e representação de dados para o avaliador <SCHEMEINLINE>amb</SCHEMEINLINE>, e também a
    <INDEX><USE>analyze</USE><SUBINDEX>nondeterministic</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>procedure,</SCHEME>
      <JAVASCRIPT>função,</JAVASCRIPT>
    </SPLITINLINE>
    básica <SCHEMEINLINE>analyze</SCHEMEINLINE>
    são idênticas às do avaliador da
    seção<SPACE/><REF NAME="sec:separating-analysis"/>, exceto pelo fato
    de que precisamos de
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>funções</JAVASCRIPT>
    </SPLITINLINE>
    de sintaxe adicionais para reconhecer
    <SPLITINLINE>
      <SCHEME>
	a forma especial <SCHEMEINLINE>amb</SCHEMEINLINE>:<FOOTNOTE>Assumimos
	que o avaliador suporta <SCHEMEINLINE>let</SCHEMEINLINE>
	(veja exercício<SPACE/><REF NAME="ex:implement-analyze-let"/>),
	que usamos em nossos programas não determinísticos.</FOOTNOTE>
      </SCHEME>
      <JAVASCRIPT>
	a forma sintática <JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE>:
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <INDEX><DECLARATION>is_amb</DECLARATION></INDEX>
      <NAME>is_amb_amb</NAME>
      <REQUIRES>functions_4_1_2</REQUIRES>
      <SCHEME>
(define (amb? exp) (tagged-list? exp 'amb))

(define (amb-choices exp) (cdr exp))
      </SCHEME>
      <JAVASCRIPT>
function is_amb(component) {
    return is_tagged_list(component, "application") &amp;&amp;
           is_name(function_expression(component)) &amp;&amp;
           symbol_of_name(function_expression(component)) === "amb";
}
function amb_choices(component) {
    return arg_expressions(component);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SPLIT>
      <SCHEME>
      </SCHEME>
      <JAVASCRIPT>
<PDF_ONLY>\newpage\noindent </PDF_ONLY>
	Continuamos a usar a função parse da
	seção<SPACE/><REF NAME="sec:representing-expressions"/>, que
	não suporta <JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE> como uma forma
	sintática e em vez disso trata <JAVASCRIPTINLINE>amb(</JAVASCRIPTINLINE><LATEX>$\ldots$</LATEX><JAVASCRIPTINLINE>)</JAVASCRIPTINLINE> como
	uma aplicação de função. A função
	<JAVASCRIPTINLINE>is_amb</JAVASCRIPTINLINE> garante que
	sempre que o nome
	<JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE> aparecer como a expressão de função
	de uma aplicação, o avaliador trate a
	<QUOTE>aplicação</QUOTE> como
	um ponto de escolha não determinístico.<FOOTNOTE>Com este tratamento,
	<JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE> não é mais um nome com
	escopo adequado. Para evitar confusão, devemos
	nos abster de declarar <JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE> como um
	nome em nossos programas não determinísticos.</FOOTNOTE>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <TEXT>
    Também devemos adicionar ao despacho em <SCHEMEINLINE>analyze</SCHEMEINLINE> uma
    cláusula que reconhecerá
    <SPLITINLINE>
      <SCHEME>esta forma especial e gerará uma procedure de execução apropriada:
      </SCHEME>
      <JAVASCRIPT>tais expressões e gerará uma função de execução
      apropriada:</JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET LATEX="yes">
      <NAME>is_amb_case_amb</NAME>
      <EXAMPLE>all_solutions_test_5</EXAMPLE>
      <SCHEME>
((amb? exp) (analyze-amb exp))
      </SCHEME>
      <JAVASCRIPT>
$\ldots$
: is_amb(component)
? analyze_amb(component)
: is_application(component)
$\ldots$
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
      </JAVASCRIPT_RUN>
    </SNIPPET>
  </TEXT>

  <TEXT>
    A
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    de nível superior <SCHEMEINLINE>ambeval</SCHEMEINLINE> (similar à versão de
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>eval</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>evaluate</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    dada na seção<SPACE/><REF NAME="sec:separating-analysis"/>) analisa a
    <SPLITINLINE>
      <SCHEME>expressão</SCHEME>
      <JAVASCRIPT>componente</JAVASCRIPT>
    </SPLITINLINE>
    dada e aplica a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    de execução resultante ao ambiente dado, junto com duas continuações dadas:
    <SNIPPET HIDE="yes">
      <NAME>analyze_amb_headline</NAME>
      <JAVASCRIPT>
// funções do SICP JS 4.3.3
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>analyze_amb</NAME>
      <REQUIRES>functions_4_1_2</REQUIRES>
      <REQUIRES>functions_4_1_3</REQUIRES>
      <REQUIRES>functions_4_1_4</REQUIRES>
      <REQUIRES>analyze_amb_headline</REQUIRES>
      <REQUIRES>is_amb_amb</REQUIRES>
      <REQUIRES>analyze_literal_amb</REQUIRES>
      <REQUIRES>analyze_variable_amb</REQUIRES>
      <REQUIRES>analyze_lambda_amb</REQUIRES>
      <REQUIRES>analyze_sequence_amb</REQUIRES>
      <REQUIRES>analyze_declaration_amb</REQUIRES>
      <REQUIRES>analyze_assignment_amb</REQUIRES>
      <REQUIRES>analyze_if_amb</REQUIRES>
      <REQUIRES>scan_out_declarations</REQUIRES>
      <REQUIRES>analyze_block_amb</REQUIRES>
      <REQUIRES>analyze_return_statement_amb</REQUIRES>
      <REQUIRES>analyze_application_amb</REQUIRES>
      <REQUIRES>analyze_amb_amb</REQUIRES>
      <SCHEME>
      (define (analyze exp)
      (cond ((self-evaluating? exp)
            (analyze-self-evaluating exp))
            ((quoted? exp) (analyze-quoted exp))
            ((variable? exp) (analyze-variable exp))
            ((assignment? exp) (analyze-assignment exp))
            ((definition? exp) (analyze-definition exp))
            ((if? exp) (analyze-if exp))
            ((lambda? exp) (analyze-lambda exp))
            ((begin? exp) (analyze-sequence (begin-actions exp)))
            ((cond? exp) (analyze (cond-&gt;if exp)))
            ((application? exp) (analyze-application exp))
            (else
            (error "Unknown expression type - - ANALYZE" exp))))
      </SCHEME>
      <JAVASCRIPT>
function analyze(component) {
    return is_literal(component)
           ? analyze_literal(component)
           : is_name(component)
           ? analyze_name(component)
           : is_amb(component)
           ? analyze_amb(component)
           : is_application(component)
           ? analyze_application(component)
           : is_operator_combination(component)
           ? analyze(operator_combination_to_application(component))
           : is_conditional(component)
           ? analyze_conditional(component)
           : is_lambda_expression(component)
           ? analyze_lambda_expression(component)
           : is_sequence(component)
           ? analyze_sequence(sequence_statements(component))
           : is_block(component)
           ? analyze_block(component)
           : is_return_statement(component)
           ? analyze_return_statement(component)
           : is_function_declaration(component)
           ? analyze(function_decl_to_constant_decl(component))
           : is_declaration(component)
           ? analyze_declaration(component)
           : is_assignment(component)
           ? analyze_assignment(component)
           : error(component, "unknown syntax -- analyze");
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <INDEX><DECLARATION>ambeval</DECLARATION></INDEX>
      <NAME>ambeval</NAME>
      <REQUIRES>analyze_amb</REQUIRES>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (ambeval exp env succeed fail)
  ((analyze exp) env succeed fail))
      </SCHEME>
      <JAVASCRIPT>
function ambeval(component, env, succeed, fail) {
    return analyze(component)(env, succeed, fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Uma continuação de
    <INDEX>success continuation (nondeterministic evaluator)</INDEX>
    <INDEX>continuation<SUBINDEX>in nondeterministic evaluator</SUBINDEX></INDEX>
    sucesso é uma
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    de dois argumentos: o valor recém-obtido e outra continuação de falha para
    ser usada se aquele valor levar a uma falha subsequente. Uma
    <INDEX>failure continuation (nondeterministic evaluator)</INDEX>
    continuação de falha
    é uma
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    sem argumentos. Então
    a forma geral de uma
    <INDEX>execution <SPLITINLINE><SCHEME>procedure</SCHEME><JAVASCRIPT>function</JAVASCRIPT></SPLITINLINE><SUBINDEX>in nondeterministic evaluator</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    de execução é
    <SNIPPET EVAL="no" LATEX="yes">
      <SCHEME>
(lambda (env succeed fail)
  ;; succeed is (lambda (value fail) $\ldots$)
  ;; fail is (lambda () $\ldots$)
  $\ldots$)
      </SCHEME>
      <JAVASCRIPT>
(env, succeed, fail) => {
    // $\texttt{succeed}\,$ is $\texttt{(value, fail) =>}~\ldots$
    // $\texttt{fail}\,$ is $\texttt{() =>}~\ldots$
    $\ldots$
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>
  <TEXT>
    Por exemplo, executar
    <SPLIT>
      <SCHEME>
	<SNIPPET EVAL="no">
	  <SCHEME>
(ambeval exp
         the-global-environment
         (lambda (value fail) value)
         (lambda () 'failed))
	  </SCHEME>
	</SNIPPET>
      </SCHEME>
      <JAVASCRIPT>
	<SNIPPET EVAL="no" LATEX="yes">
	  <JAVASCRIPT>
ambeval(<META>component</META>,
        the_global_environment,
        (value, fail) => value,
        () => "failed");
	  </JAVASCRIPT>
	</SNIPPET>
      </JAVASCRIPT>
    </SPLIT>
    tentará avaliar o
    <SPLITINLINE>
      <SCHEME>expression</SCHEME>
      <JAVASCRIPT>componente</JAVASCRIPT>
    </SPLITINLINE>
    dado e retornará ou o valor do
    <SPLITINLINE>
      <SCHEME>expression<APOS/>s</SCHEME>
      <JAVASCRIPT>componente</JAVASCRIPT>
    </SPLITINLINE>
    (se a avaliação tiver sucesso) ou o
    <SPLITINLINE>
      <SCHEME>
	símbolo <SCHEMEINLINE>failed</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	string <JAVASCRIPTINLINE>"failed"</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    (se a avaliação falhar).
    A chamada a <SCHEMEINLINE>ambeval</SCHEMEINLINE> no loop de driver mostrado
    abaixo usa
    <SPLITINLINE>
      <SCHEME>procedures,</SCHEME>
      <JAVASCRIPT>funções,</JAVASCRIPT>
    </SPLITINLINE>
    de continuação muito mais complicadas, que continuam o loop e suportam o pedido de
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>try-again</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    .
  </TEXT>

  <TEXT>
    A maior parte da complexidade do avaliador <SCHEMEINLINE>amb</SCHEMEINLINE>
    resulta das maquinações de passar as continuações à medida que as
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>funções</JAVASCRIPT>
    </SPLITINLINE>
    de execução chamam umas às outras. Ao percorrer o código a seguir, você deve comparar
    cada uma das
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>funções</JAVASCRIPT>
    </SPLITINLINE>
    de execução com a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    correspondente para o avaliador comum dada na
    seção<SPACE/><REF NAME="sec:separating-analysis"/>.
  </TEXT>

  <SUBHEADING>
    <NAME>Expressões simples</NAME>
  </SUBHEADING>

  <INDEX><USE>analyze_...</USE><SUBINDEX>nondeterministic</SUBINDEX><OPEN/></INDEX>

  <TEXT>
    As
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>funções</JAVASCRIPT>
    </SPLITINLINE>
    de execução para os tipos mais simples de expressões são
    essencialmente as mesmas que para o avaliador comum, exceto pela
    necessidade de gerenciar as continuações. As
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>funções</JAVASCRIPT>
    </SPLITINLINE>
    de execução simplesmente têm sucesso com o valor da expressão, passando adiante a continuação
    de falha que foi passada para elas.
    <SNIPPET>
      <NAME>analyze_literal_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-self-evaluating exp)
  (lambda (env succeed fail)
    (succeed exp fail)))
      </SCHEME>
      <JAVASCRIPT>
function analyze_literal(component) {
    return (env, succeed, fail) =>
             succeed(literal_value(component), fail);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>analyze_variable_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-variable exp)
  (lambda (env succeed fail)
    (succeed (lookup-variable-value exp env)
             fail)))
      </SCHEME>
      <JAVASCRIPT>
function analyze_name(component) {
    return (env, succeed, fail) =>
             succeed(lookup_symbol_value(symbol_of_name(component),
                                         env),
                     fail);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <NAME>analyze_lambda_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-lambda exp)
  (let ((vars (lambda-parameters exp))
        (bproc (analyze-sequence (lambda-body exp))))
    (lambda (env succeed fail)
      (succeed (make-procedure vars bproc env)
               fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_lambda_expression(component) {
    const params = lambda_parameter_symbols(component);
    const bfun = analyze(lambda_body(component));
    return (env, succeed, fail) =>
             succeed(make_function(params, bfun, env),
                     fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Note que procurar um
    <SPLITINLINE>
      <SCHEME>variable</SCHEME>
      <JAVASCRIPT>nome</JAVASCRIPT>
    </SPLITINLINE>
    sempre <QUOTE>tem sucesso.</QUOTE>
    <INDEX>failure, in nondeterministic computation<SUBINDEX>bug vs.</SUBINDEX></INDEX>
    Se
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>lookup-variable-value</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>lookup_symbol_value</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    falhar ao encontrar o
    <SPLITINLINE>
      <SCHEME>variable,</SCHEME>
      <JAVASCRIPT>nome,</JAVASCRIPT>
    </SPLITINLINE>
    ele sinaliza um
    erro, como de costume. Tal <QUOTE>falha</QUOTE> indica um bug
    de programa<EMDASH/>uma referência a um
    <SPLITINLINE>
      <SCHEME>variable;</SCHEME>
      <JAVASCRIPT>nome</JAVASCRIPT>
    </SPLITINLINE>
    não vinculado; não é uma indicação
    de que devemos tentar outra escolha não determinística em vez da que
    está sendo tentada atualmente.
  </TEXT>

  <LONG_PAGE lines="2"/>
  <SUBHEADING>
    <NAME>Condicionais e sequências</NAME>
  </SUBHEADING>

  <TEXT>
    Condicionais também são tratados de maneira similar ao avaliador comum. A
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    de execução gerada por
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>analyze-if</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>analyze_conditional</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    invoca a
    <SPLITINLINE>
      <SCHEME>procedure
      <SCHEMEINLINE>pproc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>função
      <JAVASCRIPTINLINE>pfun</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    de execução do predicado com uma continuação de sucesso que verifica se o valor do predicado é verdadeiro
    e prossegue para executar ou o consequente ou a alternativa. Se a
    execução de
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>pproc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>pfun</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    falhar, a continuação de falha original para
    a expressão
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	condicional
      </JAVASCRIPT>
    </SPLITINLINE>
    é chamada.
    <SNIPPET LATEX="yes">
      <NAME>analyze_if_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-if exp)
  (let ((pproc (analyze (if-predicate exp)))
        (cproc (analyze (if-consequent exp)))
        (aproc (analyze (if-alternative exp))))
   (lambda (env succeed fail)
           (pproc env
                  <EM>;; success continuation for evaluating the predicate</EM>
                  <EM>;; to obtain <SCHEMEINLINE>pred-value</SCHEMEINLINE></EM>
                  (lambda (pred-value fail2)
                    (if (true? pred-value)
                        (cproc env succeed fail2)
                        (aproc env succeed fail2)))
                  <EM>;; failure continuation for evaluating the predicate</EM>
                  fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_conditional(component) {
    const pfun = analyze(conditional_predicate(component));
    const cfun = analyze(conditional_consequent(component));
    const afun = analyze(conditional_alternative(component));
    return (env, succeed, fail) =>
             pfun(env,
                  // continuação de sucesso para avaliar o predicado
                  // para obter $\texttt{pred\char`_value}$
                  (pred_value, fail2) =>
                    is_truthy(pred_value)
                    ? cfun(env, succeed, fail2)
                    : afun(env, succeed, fail2),
                  // continuação de falha para avaliar o predicado
                  fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    <SPLIT>
      <SCHEME>
	Sequências também são tratadas da mesma maneira que no avaliador
	anterior, exceto pelas maquinações na subprocedure
	<SCHEMEINLINE>sequentially</SCHEMEINLINE> que são necessárias para passar as
	continuações. Isto é, para executar sequencialmente <SCHEMEINLINE>a</SCHEMEINLINE>
	e então <SCHEMEINLINE>b</SCHEMEINLINE>, chamamos
	<SCHEMEINLINE>a</SCHEMEINLINE> com uma continuação de sucesso que chama
	<SCHEMEINLINE>b</SCHEMEINLINE>.
	<SNIPPET>
	  <SCHEME>
	    (define (analyze-sequence exps)
	    (define (sequentially a b)
	    (lambda (env succeed fail)
	    (a env
            ;; success continuation for calling a
            (lambda (a-value fail2)
            (b env succeed fail2))
            ;; failure continuation for calling a
            fail)))
	    (define (loop first-proc rest-procs)
	    (if (null? rest-procs)
            first-proc
            (loop (sequentially first-proc (car rest-procs))
            (cdr rest-procs))))
	    (let ((procs (map analyze exps)))
	    (if (null? procs)
            (error "Empty sequence - - ANALYZE"))
	    (loop (car procs) (cdr procs))))
	  </SCHEME>
	</SNIPPET>
      </SCHEME>
      <JAVASCRIPT>
	Sequências também são tratadas da mesma maneira que no avaliador
	anterior, exceto pelas maquinações na subfunção
	<SCHEMEINLINE>sequentially</SCHEMEINLINE> que são necessárias para passar as
	continuações. Isto é, para executar sequencialmente <SCHEMEINLINE>a</SCHEMEINLINE>
	e então <SCHEMEINLINE>b</SCHEMEINLINE>, chamamos
	<SCHEMEINLINE>a</SCHEMEINLINE> com uma continuação de sucesso que chama
	<SCHEMEINLINE>b</SCHEMEINLINE>.
	<SNIPPET POSTPADDING="no" LATEX="yes">
	  <NAME>analyze_sequence_amb</NAME>
	  <EXAMPLE>all_solutions_test_4</EXAMPLE>
	  <JAVASCRIPT>
function analyze_sequence(stmts) {
    function sequentially(a, b) {
        return (env, succeed, fail) =>
                 a(env,
                   // continuação de sucesso para chamar $\texttt{a}$
                   (a_value, fail2) =>
                     is_return_value(a_value)
                     ? succeed(a_value, fail2)
                     : b(env, succeed, fail2),
                   // continuação de falha para chamar $\texttt{a}$
                   fail);
    }
    function loop(first_fun, rest_funs) {
        return is_null(rest_funs)
               ? first_fun
               : loop(sequentially(first_fun, head(rest_funs)),
                      tail(rest_funs));
    }
    const funs = map(analyze, stmts);
    return is_null(funs)
           ? env => undefined
           : loop(head(funs), tail(funs));
}
	  </JAVASCRIPT>
	</SNIPPET>
      </JAVASCRIPT>
    </SPLIT>
  </TEXT>

  <SUBHEADING>
    <NAME>
      <SPLITINLINE>
	<SCHEME>Definitions</SCHEME>
	<JAVASCRIPT>Declarações</JAVASCRIPT>
      </SPLITINLINE>
      e atribuições
    </NAME>
  </SUBHEADING>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>Definitions</SCHEME>
      <JAVASCRIPT>Declarações</JAVASCRIPT>
    </SPLITINLINE>
    são outro caso onde devemos fazer algum esforço para
    gerenciar as continuações, porque é necessário avaliar a
    <SPLITINLINE>
      <SCHEME>
	expressão definition-value antes de realmente definir a nova variável.
      </SCHEME>
      <JAVASCRIPT>
	expressão declaration-value antes de realmente declarar o novo nome.
      </JAVASCRIPT>
    </SPLITINLINE>
    Para realizar isso, a
    <SPLITINLINE>
      <SCHEME>procedure
      <SCHEMEINLINE>vproc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>função
      <SCHEMEINLINE>vfun</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    de execução do
    <SPLITINLINE>
      <SCHEME>definition-value</SCHEME>
      <JAVASCRIPT>declaration-value</JAVASCRIPT>
    </SPLITINLINE>
    é chamada com o ambiente, uma continuação de sucesso e a
    continuação de falha. Se a execução de
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>vproc</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<SCHEMEINLINE>vfun</SCHEMEINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    tiver sucesso, obtendo um valor <SCHEMEINLINE>val</SCHEMEINLINE> para a
    <SPLITINLINE>
      <SCHEME>
	variável definida, a variável é definida e o sucesso é propagado:
      </SCHEME>
      <JAVASCRIPT>
	nome declarado, o nome é declarado e o sucesso é propagado:
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET>
      <NAME>analyze_declaration_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-definition exp)
  (let ((var (definition-variable exp))
        (vproc (analyze (definition-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)
               (define-variable! var val env)
               (succeed 'ok fail2))
             fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_declaration(component) {
    const symbol = declaration_symbol(component);
    const vfun = analyze(declaration_value_expression(component));
    return (env, succeed, fail) =>
             vfun(env,
                  (val, fail2) => {
                      assign_symbol_value(symbol, val, env);
                      return succeed(undefined, fail2);
                  },
                  fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    Atribuições
    <INDEX>failure continuation (nondeterministic evaluator)<SUBINDEX>constructed by assignment</SUBINDEX></INDEX>
    são mais interessantes. Este é o primeiro lugar onde
    realmente usamos as continuações, em vez de apenas passá-las adiante.
    A
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    de execução para atribuições começa como a para
    <SPLITINLINE>
      <SCHEME>definitions.</SCHEME>
      <JAVASCRIPT>declarações.</JAVASCRIPT>
    </SPLITINLINE>
    Ela primeiro tenta
    obter o novo valor a ser atribuído ao
    <SPLITINLINE>
      <SCHEME>variable.</SCHEME>
      <JAVASCRIPT>nome.</JAVASCRIPT>
    </SPLITINLINE>
    Se esta avaliação de
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>vproc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>vfun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    falhar, a atribuição falha.
  </TEXT>

  <TEXT>
    Se
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>vproc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>vfun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    tiver sucesso, no entanto, e prosseguirmos para fazer a atribuição, devemos considerar a
    possibilidade de que este ramo da computação possa falhar mais tarde, o que
    exigirá que retrocedamos para fora da atribuição. Assim, devemos providenciar para
    desfazer a atribuição como parte do processo de backtracking.<FOOTNOTE>Nós
    <SPLITINLINE>
      <SCHEME>
	não nos preocupamos em desfazer definições,
	já que podemos
	assumir que
	<INDEX>internal definition<SUBINDEX><ORDER>nondeterministic</ORDER>in nondeterministic evaluator</SUBINDEX></INDEX>
	definições internas
	são removidas por scanning
	(seção<SPACE/><REF NAME="sec:internal-definitions"/>).
      </SCHEME>
      <JAVASCRIPT>
	não nos preocupamos em desfazer declarações, já que assumimos que um
	nome não pode ser usado antes da avaliação de sua declaração,
	<INDEX>internal declaration<SUBINDEX><ORDER>nondeterministic</ORDER>in nondeterministic evaluator</SUBINDEX></INDEX>
	então seu valor anterior não importa.
      </JAVASCRIPT>
    </SPLITINLINE></FOOTNOTE>
  </TEXT>

  <TEXT>
    Isso é realizado dando a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>vproc</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>vfun</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    uma continuação de sucesso (marcada com o comentário <QUOTE>*1*</QUOTE> abaixo)
    que salva o valor antigo da variável antes de atribuir o novo valor à
    variável e prosseguir a partir da atribuição. A continuação de
    falha que é passada junto com o valor da atribuição (marcada com o
    comentário <QUOTE>*2*</QUOTE> abaixo) restaura o valor antigo da variável
    antes de continuar a falha. Isto é, uma atribuição bem-sucedida fornece uma
    continuação de falha que interceptará uma falha subsequente; qualquer
    falha que de outra forma teria chamado <SCHEMEINLINE>fail2</SCHEMEINLINE> chama esta
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    em vez disso, para desfazer a atribuição antes de realmente chamar
    <SCHEMEINLINE>fail2</SCHEMEINLINE>.
    <SNIPPET POSTPADDING="no">
      <NAME>analyze_assignment_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-assignment exp)
  (let ((var (assignment-variable exp))
        (vproc (analyze (assignment-value exp))))
    (lambda (env succeed fail)
      (vproc env
             (lambda (val fail2)        <EM>; *1*</EM>
               (let ((old-value
                     (lookup-variable-value var env)))
                 (set-variable-value! var val env)
                 (succeed 'ok
                          (lambda ()    <EM>; *2*</EM>
                            (set-variable-value! var
                                                 old-value
                                                 env)
                            (fail2)))))
             fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_assignment(component) {
    const symbol = assignment_symbol(component);
    const vfun = analyze(assignment_value_expression(component));
    return (env, succeed, fail) =>
             vfun(env,
                  (val, fail2) => {              // *1*
                      const old_value = lookup_symbol_value(symbol,
                                                            env);
                      assign_symbol_value(symbol, val, env);
                      return succeed(val,
                                     () => {     // *2*
                                         assign_symbol_value(symbol,
                                                             old_value,
                                                             env);
                                         return fail2();
                                     });
                  },
                  fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SPLIT>
    <SCHEME>
    </SCHEME>
    <JAVASCRIPT>
      <SUBHEADING>
	<NAME>Instruções return e blocos</NAME>
      </SUBHEADING>

      <TEXT>
	Analisar instruções return é direto.
	A expressão return é analisada para produzir uma função de execução.
	A função de execução para a instrução return chama aquela função de
	execução com uma continuação de sucesso que envolve o valor de retorno
	em um objeto de valor de retorno e o passa para a continuação de sucesso original.
	<SNIPPET>
	  <NAME>analyze_return_statement_amb</NAME>
	  <EXAMPLE>all_solutions_test_4</EXAMPLE>
	  <JAVASCRIPT>
function analyze_return_statement(component) {
    const rfun = analyze(return_expression(component));
    return (env, succeed, fail) =>
             rfun(env,
                  (val, fail2) =>
                    succeed(make_return_value(val), fail2),
                  fail);
}
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>
      <TEXT>
	A função de execução para blocos chama a função de execução do corpo
	em um ambiente estendido, sem alterar as continuações de sucesso ou
	falha.
	<SNIPPET POSTPADDING="no">
	  <NAME>analyze_block_amb</NAME>
	  <REQUIRES>list_of_unassigned</REQUIRES>
	  <EXAMPLE>all_solutions_test_4</EXAMPLE>
	  <JAVASCRIPT>
function analyze_block(component) {
    const body = block_body(component);
    const locals = scan_out_declarations(body);
    const unassigneds = list_of_unassigned(locals);
    const bfun = analyze(body);
    return (env, succeed, fail) =>
             bfun(extend_environment(locals, unassigneds, env),
                  succeed,
                  fail);
}
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>

  <SUBHEADING>
    <NAME>
      <SPLITINLINE>
	<SCHEME>Procedure</SCHEME>
	<JAVASCRIPT>Aplicações de função</JAVASCRIPT>
      </SPLITINLINE>
    </NAME>
  </SUBHEADING>

  <TEXT>
    A
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    de execução para aplicações não contém novas ideias exceto pela complexidade técnica
    de gerenciar as continuações. Esta complexidade surge em
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>analyze-application</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT>
      <JAVASCRIPTINLINE>analyze_@application</JAVASCRIPTINLINE>,</JAVASCRIPT>
    </SPLITINLINE>
    devido à necessidade de acompanhar as continuações de sucesso e falha à medida que
    avaliamos as
    <SPLITINLINE>
      <SCHEME>operands.</SCHEME>
      <JAVASCRIPT>expressões de argumento.</JAVASCRIPT>
    </SPLITINLINE>
    Usamos uma
    <SPLITINLINE>
      <SCHEME>procedure <SCHEMEINLINE>get-args</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>função <JAVASCRIPTINLINE>get_args</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    para avaliar a lista de
    <SPLITINLINE>
      <SCHEME>operands,</SCHEME>
      <JAVASCRIPT>expressões de argumento,</JAVASCRIPT>
    </SPLITINLINE>
    em vez de um simples
    <SCHEMEINLINE>map</SCHEMEINLINE> como no avaliador comum.
    <SNIPPET>
      <NAME>analyze_application_amb</NAME>
      <REQUIRES>get_args_amb</REQUIRES>
      <REQUIRES>execute_application_amb</REQUIRES>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (analyze-application exp)
  (let ((fproc (analyze (operator exp)))
        (aprocs (map analyze (operands exp))))
    (lambda (env succeed fail)
      (fproc env
             (lambda (proc fail2)
               (get-args aprocs
                         env
                         (lambda (args fail3)
                           (execute-application
                            proc args succeed fail3))
                         fail2))
             fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_application(component) {
    const ffun = analyze(function_expression(component));
    const afuns = map(analyze, arg_expressions(component));
    return (env, succeed, fail) =>
             ffun(env,
                  (fun, fail2) =>
                    get_args(afuns,
                             env,
                             (args, fail3) =>
                               execute_application(fun,
                                                   args,
                                                   succeed,
                                                   fail3),
                             fail2),
                  fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <INDEX><USE>analyze_...</USE><SUBINDEX>nondeterministic</SUBINDEX><CLOSE/></INDEX>

  <TEXT>
    <SPLITINLINE>
      <SCHEME>
	Em <SCHEMEINLINE>get-args</SCHEMEINLINE>, note como
	<SCHEMEINLINE>cdr</SCHEMEINLINE>ring down the list of
	<SCHEMEINLINE>aproc</SCHEMEINLINE>
	execution procedures and
	<SCHEMEINLINE>cons</SCHEMEINLINE>ing
	up the resulting list of
	<SCHEMEINLINE>args</SCHEMEINLINE> is accomplished by calling each
	<SCHEMEINLINE>aproc</SCHEMEINLINE>
	in the list with a success continuation that recursively calls
	<SCHEMEINLINE>get-args</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	Em <JAVASCRIPTINLINE>get_args</JAVASCRIPTINLINE>,
	note como percorrer a lista de funções
	<JAVASCRIPTINLINE>afun</JAVASCRIPTINLINE>
	de execução
	e construir a lista resultante de
	<SCHEMEINLINE>args</SCHEMEINLINE>
	é realizado chamando cada
	<JAVASCRIPTINLINE>afun</JAVASCRIPTINLINE>
	na lista com uma continuação de sucesso que chama recursivamente
	<JAVASCRIPTINLINE>get_args</JAVASCRIPTINLINE>.<DO_BREAK_PAGE/>
      </JAVASCRIPT>
    </SPLITINLINE>
    Cada uma dessas chamadas recursivas a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>get-args</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>get_args</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    tem uma continuação de sucesso cujo valor é a
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>cons</SCHEMEINLINE>
	do argumento recém-obtido na lista de argumentos acumulados:
      </SCHEME>
      <JAVASCRIPT>
	nova lista resultante do uso de
	<JAVASCRIPTINLINE>pair</JAVASCRIPTINLINE>
	para adicionar o argumento recém-obtido
	à lista de argumentos acumulados:
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET LATEX="yes">
      <NAME>get_args_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (get-args aprocs env succeed fail)
  (if (null? aprocs)
      (succeed '() fail)
      ((car aprocs) env
                    <EM>;; success continuation for this <SCHEMEINLINE>aproc</SCHEMEINLINE></EM>
                    (lambda (arg fail2)
                      (get-args (cdr aprocs)
                                env
                                <EM>;; success continuation for recursive</EM>
                                <EM>;; call to <SCHEMEINLINE>get-args</SCHEMEINLINE></EM>
                                (lambda (args fail3)
                                  (succeed (cons arg args)
                                           fail3))
                                fail2))
                    fail)))
      </SCHEME>
      <JAVASCRIPT>
function get_args(afuns, env, succeed, fail) {
    return is_null(afuns)
           ? succeed(null, fail)
           : head(afuns)(env,
                         // continuação de sucesso para este $\texttt{afun}$
                         (arg, fail2) =>
                           get_args(tail(afuns),
                                    env,
                                    // continuação de sucesso para
                                    // chamada recursiva a $\texttt{get\char`_args}$
                                    (args, fail3) =>
                                      succeed(pair(arg, args),
                                              fail3),
                                    fail2),
                         fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <TEXT>
    A aplicação
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    real, que é executada por
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>execute-application</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>execute_application</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    é realizada da mesma maneira que para o avaliador comum, exceto pela
    necessidade de gerenciar as continuações.
    <SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>execute_application</DECLARATION><SUBINDEX>nondeterministic</SUBINDEX></INDEX>
      <NAME>execute_application_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME>
(define (execute-application proc args succeed fail)
  (cond ((primitive-procedure? proc)
         (succeed (apply-primitive-procedure proc args)
                  fail))
        ((compound-procedure? proc)
         ((procedure-body proc)
          (extend-environment (procedure-parameters proc)
                              args
                              (procedure-environment proc))
          succeed
          fail))
        (else
         (error
          "Unknown procedure type - - EXECUTE-APPLICATION"
          proc))))
      </SCHEME>
      <JAVASCRIPT>
function execute_application(fun, args, succeed, fail) {
    return is_primitive_function(fun)
           ? succeed(apply_primitive_function(fun, args),
                     fail)
           : is_compound_function(fun)
           ? function_body(fun)(
                 extend_environment(function_parameters(fun),
                                    args,
                                    function_environment(fun)),
                 (body_result, fail2) =>
                   succeed(is_return_value(body_result)
                           ? return_value_content(body_result)
                           : undefined,
                           fail2),
                 fail)
           : error(fun, "unknown function type - execute_application");
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <DO_BREAK_PAGE/>
  <SUBHEADING>
    <NAME>Avaliando expressões <SCHEMEINLINE>amb</SCHEMEINLINE></NAME>
  </SUBHEADING>

  <TEXT>
    A forma
    <SPLITINLINE>
      <SCHEME>special</SCHEME>
      <JAVASCRIPT>sintática</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>amb</SCHEMEINLINE> é o elemento chave na linguagem não determinística. Aqui vemos a
    essência do processo de interpretação e a razão para acompanhar
    as continuações. A
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    de execução para <SCHEMEINLINE>amb</SCHEMEINLINE> define um loop
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-next</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>try_next</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    que percorre as
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>funções</JAVASCRIPT>
    </SPLITINLINE>
    de execução para todos os valores possíveis da expressão <SCHEMEINLINE>amb</SCHEMEINLINE>. Cada
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    de execução é chamada com uma
    <INDEX>failure continuation (nondeterministic evaluator)<SUBINDEX><ORDER>constructed by amb</ORDER>constructed by <SCHEMEINLINE>amb</SCHEMEINLINE></SUBINDEX></INDEX>
    continuação de falha que tentará a próxima. Quando
    não houver mais alternativas a tentar, toda a
    expressão <SCHEMEINLINE>amb</SCHEMEINLINE> falha.
    <SNIPPET POSTPADDING="no">
      <INDEX><DECLARATION>analyze_amb</DECLARATION></INDEX>
      <NAME>analyze_amb_amb</NAME>
      <EXAMPLE>all_solutions_test_4</EXAMPLE>
      <SCHEME POSTPADDING="no">
(define (analyze-amb exp)
  (let ((cprocs (map analyze (amb-choices exp))))
    (lambda (env succeed fail)
      (define (try-next choices)
        (if (null? choices)
            (fail)
            ((car choices) env
             succeed
             (lambda ()
               (try-next (cdr choices))))))
      (try-next cprocs))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_amb(component) {
    const cfuns = map(analyze, amb_choices(component));
    return (env, succeed, fail) => {
               function try_next(choices) {
                   return is_null(choices)
                          ? fail()
                          : head(choices)(env,
                                          succeed,
                                          () =>
                                            try_next(tail(choices)));
               }
               return try_next(cfuns);
           };
}
      </JAVASCRIPT>
    </SNIPPET>
  </TEXT>

  <SUBHEADING>
    <NAME>Driver loop</NAME>
  </SUBHEADING>

  <INDEX>driver loop<SUBINDEX><ORDER>nondeterministic</ORDER>in nondeterministic evaluator</SUBINDEX></INDEX>

  <TEXT>
    O loop de driver para o avaliador <SCHEMEINLINE>amb</SCHEMEINLINE> é
    complexo, devido ao mecanismo que permite ao usuário tentar novamente avaliar
    <SPLITINLINE>
      <SCHEME>uma expressão.</SCHEME>
      <JAVASCRIPT>um programa.</JAVASCRIPT>
    </SPLITINLINE>
    O driver usa uma
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    chamada
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>internal-loop</SCHEMEINLINE>,</SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>internal_loop</JAVASCRIPTINLINE>,
      </JAVASCRIPT>
    </SPLITINLINE>
    que recebe como argumento uma
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    <INDEX>failure continuation (nondeterministic evaluator)<SUBINDEX>constructed by driver loop</SUBINDEX></INDEX>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>try-again</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    A intenção é que chamar
    <SPLITINLINE><SCHEME>
      <SCHEMEINLINE>try-again</SCHEMEINLINE>
    </SCHEME>
    <JAVASCRIPT>
      <JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
    </JAVASCRIPT></SPLITINLINE>
    deva prosseguir para a próxima alternativa não tentada na avaliação
    não determinística.
    <SPLITINLINE><SCHEME>
      <SCHEMEINLINE>Internal-loop</SCHEMEINLINE>
    </SCHEME>
    <JAVASCRIPT>A função
    <JAVASCRIPTINLINE>internal_loop</JAVASCRIPTINLINE>
    </JAVASCRIPT></SPLITINLINE>
    ou chama
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    em resposta ao usuário digitar
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    no loop de driver, ou então inicia uma nova avaliação chamando
    <SCHEMEINLINE>ambeval</SCHEMEINLINE>.
  </TEXT>

  <TEXT>
    A continuação de falha para esta chamada a
    <SCHEMEINLINE>ambeval</SCHEMEINLINE>
    <!-- %(marked <QUOTE>*2*</QUOTE> below)-->
    informa ao usuário que não há mais valores e reinvoca o loop de
    driver.
  </TEXT>

  <TEXT>
    A continuação de sucesso para a chamada a <SCHEMEINLINE>ambeval</SCHEMEINLINE>
    <!-- %(marked <QUOTE>*1*</QUOTE> below)-->
    é mais sutil. Imprimimos o valor obtido e então
    <SPLITINLINE>
      <SCHEME>
	invocamos o loop interno novamente
      </SCHEME>
      <JAVASCRIPT>
	reinvocamos o loop interno
      </JAVASCRIPT>
    </SPLITINLINE>
    com uma
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>try-again</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    que será capaz de tentar a próxima alternativa. Esta
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>next-alternative</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>next_alternative</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    é o segundo argumento que foi passado para a continuação de sucesso.
    Ordinariamente, pensamos neste segundo argumento como uma continuação de falha a
    ser usada se a ramificação de avaliação atual falhar mais tarde. Neste caso,
    no entanto, completamos uma avaliação bem-sucedida, então podemos invocar a
    ramificação alternativa de <QUOTE>falha</QUOTE> para buscar avaliações bem-sucedidas
    adicionais.
    <SNIPPET HIDE="yes">
      <NAME>driver_loop_amb_example</NAME>
      <SCHEME>
(driver-loop)
      </SCHEME>
      <JAVASCRIPT>
driver_loop();
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET>
      <INDEX>prompts<SUBINDEX>nondeterministic evaluator</SUBINDEX></INDEX>
      <INDEX><DECLARATION>driver_loop</DECLARATION><SUBINDEX>for nondeterministic evaluator</SUBINDEX></INDEX>
      <NAME>driver_loop_amb</NAME>
      <REQUIRES>ambeval</REQUIRES>
      <REQUIRES>user_print</REQUIRES>
      <REQUIRES>user_read</REQUIRES>
      <EXAMPLE>driver_loop_amb_example</EXAMPLE>
      <SCHEME>
(define input-prompt ";;; Amb-Eval input:")
(define output-prompt ";;; Amb-Eval value:")

(define (driver-loop)
  (define (internal-loop try-again)
    (prompt-for-input input-prompt)
    (let ((input (read)))
      (if (eq? input 'try-again)
          (try-again)
          (begin
            (newline)
            (display ";;; Starting a new problem ")
            (ambeval input
                     the-global-environment
                     <EM>;; <SCHEMEINLINE>ambeval</SCHEMEINLINE> success</EM>
                     (lambda (val next-alternative)
                       (announce-output output-prompt)
                       (user-print val)
                       (internal-loop next-alternative))
                    <EM>;; <SCHEMEINLINE>ambeval</SCHEMEINLINE> failure</EM>
                    (lambda ()
                      (announce-output
                       ";;; There are no more values of")
                      (user-print input)
                      (driver-loop)))))))
  (internal-loop
   (lambda ()
     (newline)
     (display ";;; There is no current problem")
     (driver-loop))))
      </SCHEME>
      <JAVASCRIPT>
const input_prompt = "amb-evaluate input:";
const output_prompt =  "amb-evaluate value:";

function driver_loop(env) {
    function internal_loop(retry) {
        const input = user_read(input_prompt);
        if (is_null(input)) {
            display("evaluator terminated");
        } else if (input === "retry") {
            return retry();
        } else {
            display("Starting a new problem");
            const program = parse(input);
            const locals = scan_out_declarations(program);
            const unassigneds = list_of_unassigned(locals);
            const program_env = extend_environment(
                                    locals, unassigneds, env);
            return ambeval(
                       program,
                       program_env,
                       // ambeval sucesso
                       (val, next_alternative) => {
                           user_print(output_prompt, val);
                           return internal_loop(next_alternative);
                       },
                       // ambeval falha
                       () => {
                           display("There are no more values of");
                           display(input);
                           return driver_loop(program_env);
                       });
        }
    }
    return internal_loop(() => {
                             display("There is no current problem");
                             return driver_loop(env);
                         });
}
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
const input_prompt = "amb-evaluate input:";
const output_prompt =  "amb-evaluate value:";
function driver_loop() {
    function internal_loop(retry) {
        const input = user_read(input_prompt);
        if (is_null(input)) {
        display("--- evaluator terminated ---", "");
        } else if (input === "retry") {
            display("----------------------------",
                    input_prompt + "\n" + input + "\n");
            return retry();
        } else {
            display("--- starting new problem ---",
                    input_prompt + "\n" + input + "\n");
            ambeval(parse("{ " + input + " }"),
                the_global_environment,
                // ambeval sucesso
                (val, next_alternative) => {
                    user_print(output_prompt, val);
                    return internal_loop(next_alternative);
                },
                // ambeval falha
                () => {
                    display("----------------------------",
                            "no more values of:\n" + input + "\n");
                    return driver_loop();
                });
        }
    }
    return internal_loop(
               () => {
                   display("---  no current problem  ---", "");
                   return driver_loop();
               });
}
      </JAVASCRIPT_RUN>
    </SNIPPET>
    A chamada inicial a
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>internal-loop</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>internal_loop</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    usa uma
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT><JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE></JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    que reclama que não há problema atual e reinicia o loop de driver.
    Este é o comportamento que acontecerá se o usuário digitar
    <SPLITINLINE>
      <SCHEME><SCHEMEINLINE>try-again</SCHEMEINLINE></SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>retry</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    quando não houver avaliação em andamento.
  </TEXT>
  <SPLIT>
    <JAVASCRIPT>
      <TEXT>
	Iniciamos o loop de driver como de costume, configurando o ambiente global
	e passando-o como o ambiente envolvente para a primeira iteração de
	<JAVASCRIPTINLINE>driver_loop</JAVASCRIPTINLINE>.
	<SNIPPET EVAL="no" POSTPADDING="no">
	  <JAVASCRIPT>
const the_global_environment = setup_environment();
driver_loop(the_global_environment);
	  </JAVASCRIPT>
	</SNIPPET>
      </TEXT>
    </JAVASCRIPT>
  </SPLIT>
  <DO_BREAK_PAGE/>
  <EXERCISE>
    Implemente uma nova forma
    <SPLITINLINE>
      <SCHEME>special</SCHEME>
      <JAVASCRIPT>sintática</JAVASCRIPT>
    </SPLITINLINE>
    <SCHEMEINLINE>ramb</SCHEMEINLINE> que é como
    <SCHEMEINLINE>amb</SCHEMEINLINE> exceto que ela pesquisa alternativas em uma
    ordem aleatória, em vez de da esquerda para a direita. Mostre como isso pode ajudar com
    o problema de Alyssa no exercício<SPACE/><REF NAME="ex:sentence-generate"/>.
    <LABEL NAME="ex:ramb"/>
  </EXERCISE>


  <EXERCISE>
    <SPLITINLINE>
      <SCHEME>
	Implemente um novo tipo de atribuição chamada
	<SCHEMEINLINE>permanent-set!</SCHEMEINLINE> que
      </SCHEME>
      <JAVASCRIPT>
	Altere a implementação de atribuição para que ela
      </JAVASCRIPT>
    </SPLITINLINE>
    não seja desfeita após falha. Por exemplo, podemos escolher dois elementos distintos
    de uma lista e contar o número de tentativas necessárias para fazer uma
    escolha bem-sucedida da seguinte forma:
    <SNIPPET EVAL="no">
      <SCHEME>
(define count 0)

(let ((x (an-element-of '(a b c)))
      (y (an-element-of '(a b c))))
  (permanent-set! count (+ count 1))
  (require (not (eq? x y)))
  (list x y count))
      </SCHEME>
      <SCHEMEOUTPUT>
;;; Starting a new problem
;;; Amb-Eval value:
(a b 2)

;;; Amb-Eval input:
      </SCHEMEOUTPUT>
      <JAVASCRIPT>
let count = 0;

let x = an_element_of("a", "b", "c");
let y = an_element_of("a", "b", "c");
count = count + 1;
require(x !== y);
list(x, y, count);
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
Iniciando um novo problema
amb-evaluate value:
["a", ["b", [2, null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SNIPPET EVAL="no">
      <SCHEME>
try-again
      </SCHEME>
      <SCHEMEOUTPUT>
;;; Amb-Eval value:
(a c 3)
      </SCHEMEOUTPUT>
      <JAVASCRIPT_PROMPT>
amb-evaluate input:
      </JAVASCRIPT_PROMPT>
      <JAVASCRIPT>
retry
      </JAVASCRIPT>
      <JAVASCRIPT_OUTPUT>
amb-evaluate value:
["a", ["c", [3, null]]]
      </JAVASCRIPT_OUTPUT>
    </SNIPPET>
    <SPLIT>
      <SCHEME>
	Quais valores teriam sido exibidos se tivéssemos usado
	<SCHEMEINLINE>set!</SCHEMEINLINE> aqui em vez de
	<SCHEMEINLINE>permanent-set!</SCHEMEINLINE>?
      </SCHEME>
      <JAVASCRIPT>
	Quais valores teriam sido exibidos se tivéssemos usado
	o significado original de atribuição em vez de
	atribuição permanente?
      </JAVASCRIPT>
    </SPLIT>
    <LABEL NAME="ex:permanent-set"/>
  </EXERCISE>

  <SPLIT>
    <SCHEME>
      <EXERCISE>
	<LABEL NAME="ex:if-fail_scheme"/>
	Implemente uma nova construção chamada <SCHEMEINLINE>if-fail</SCHEMEINLINE>
	que permite ao usuário capturar a falha de uma expressão.
	<SCHEMEINLINE>If-fail</SCHEMEINLINE> recebe duas expressões. Ela avalia
	a primeira expressão normalmente e retorna normalmente se a avaliação
	tiver sucesso. Se a avaliação falhar, no entanto, o valor da segunda
	expressão é retornado, como no seguinte exemplo:
	<SNIPPET EVAL="no">
	  <SCHEME>
	  </SCHEME>
	  <SCHEMEOUTPUT>
;;; Amb-Eval input:
	  </SCHEMEOUTPUT>
	</SNIPPET>
	<SNIPPET EVAL="no">
	  <SCHEME>
(if-fail (let ((x (an-element-of '(1 3 5))))
           (require (even? x))
           x)
         'all-odd)
	  </SCHEME>
	  <SCHEMEOUTPUT>
;;; Starting a new problem
;;; Amb-Eval value:
all-odd

;;; Amb-Eval input:
	  </SCHEMEOUTPUT>
	</SNIPPET>
	<SNIPPET EVAL="no">
	  <SCHEME>
(if-fail (let ((x (an-element-of '(1 3 5 8))))
           (require (even? x))
           x)
         'all-odd)
	  </SCHEME>
	  <SCHEMEOUTPUT>
;;; Starting a new problem
;;; Amb-Eval value:
8
	  </SCHEMEOUTPUT>
	</SNIPPET>
      </EXERCISE>
    </SCHEME>
    <JAVASCRIPT>
      <EXERCISE>
	<LABEL NAME="ex:if-fail"/>
	Abusaremos horrivelmente da sintaxe para instruções condicionais,
	implementando uma construção da seguinte forma:
	<SNIPPET EVAL="no" LATEX="yes">
	  <JAVASCRIPT>
if (evaluation_succeeds_take) { $statement$ } else { $alternative$ }
	  </JAVASCRIPT>
	</SNIPPET>
	A construção permite ao usuário capturar a falha de uma
	instrução. Ela avalia a instrução normalmente e retorna
	normalmente se a avaliação tiver sucesso. Se a avaliação falhar,
	no entanto, a instrução alternativa dada
	é avaliada, como no seguinte exemplo:
	<SNIPPET EVAL="no">
	  <JAVASCRIPT_PROMPT>
amb-evaluate input:
	  </JAVASCRIPT_PROMPT>
	  <JAVASCRIPT>
if (evaluation_succeeds_take) {
    const x = an_element_of(list(1, 3, 5));
    require(is_even(x));
    x;
} else {
    "all odd";
}
	  </JAVASCRIPT>
	  <JAVASCRIPT_OUTPUT>
Iniciando um novo problema
amb-evaluate value:
"all odd"
	  </JAVASCRIPT_OUTPUT>
	</SNIPPET>
	<SNIPPET EVAL="no">
	  <JAVASCRIPT_PROMPT>
amb-evaluate input:
	  </JAVASCRIPT_PROMPT>
	  <JAVASCRIPT>
if (evaluation_succeeds_take) {
    const x = an_element_of(list(1, 3, 5, 8));
    require(is_even(x));
    x;
} else {
    "all odd";
}
	  </JAVASCRIPT>
	  <JAVASCRIPT_OUTPUT>
Iniciando um novo problema
amb-evaluate value:
8
	  </JAVASCRIPT_OUTPUT>
	</SNIPPET>
	Implemente esta construção estendendo o avaliador
	<JAVASCRIPTINLINE>amb</JAVASCRIPTINLINE>
	. Dica: A função
	<JAVASCRIPTINLINE>is_amb</JAVASCRIPTINLINE> mostra
	como abusar da sintaxe JavaScript existente para implementar
	uma nova forma sintática.
      </EXERCISE>
    </JAVASCRIPT>
  </SPLIT>

  <EXERCISE>
    <LABEL NAME="ex:combine_permanent_if_fail"/>
    Com
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>permanent-set!</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	o novo tipo de atribuição
      </JAVASCRIPT>
    </SPLITINLINE>
    como descrito no exercício<SPACE/><REF NAME="ex:permanent-set"/> e
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>if-fail</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	a construção
	<SNIPPET EVAL="no" LATEX="yes">
	  <JAVASCRIPT>
if (evaluation_succeeds_take) { $\ldots$ } else { $\ldots$ }
      </JAVASCRIPT>
	</SNIPPET>
      </JAVASCRIPT>
    </SPLITINLINE>
    como no exercício<SPACE/><REF NAME="ex:if-fail"/>, qual será o resultado de
    avaliar
    <SNIPPET EVAL="no" POSTPADDING="no">
      <SCHEME>
(let ((pairs '()))
  (if-fail (let ((p (prime-sum-pair '(1 3 5 8) '(20 35 110))))
             (permanent-set! pairs (cons p pairs))
             (amb))
           pairs))
      </SCHEME>
      <JAVASCRIPT>
let pairs = null;
if (evaluation_succeeds_take) {
    const p = prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));
    pairs = pair(p, pairs); // usando atribuição permanente
    amb();
} else {
    pairs;
}
      </JAVASCRIPT>
    </SNIPPET>
  </EXERCISE>

  <EXERCISE>
    <LABEL NAME="ex:require_special"/>
    Se não tivéssemos percebido que
    <INDEX><USE>require</USE><SUBINDEX>as a syntactic form</SUBINDEX></INDEX>
    <SCHEMEINLINE>require</SCHEMEINLINE> poderia ser
    implementada como uma
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    comum que usa <SCHEMEINLINE>amb</SCHEMEINLINE>, a ser definida pelo usuário como
    parte de um programa não determinístico, teríamos que implementá-la
    como uma forma
    <SPLITINLINE>
      <SCHEME>special</SCHEME>
      <JAVASCRIPT>sintática</JAVASCRIPT>
    </SPLITINLINE>
    . Isso exigiria
    <SPLITINLINE>
      <SCHEME>procedures</SCHEME>
      <JAVASCRIPT>funções</JAVASCRIPT>
    </SPLITINLINE>
    de sintaxe
    <SNIPPET EVAL="no">
      <SCHEME>
(define (require? exp) (tagged-list? exp 'require))

(define (require-predicate exp) (cadr exp))
      </SCHEME>
      <JAVASCRIPT>
function is_require(component) {
    return is_tagged_list(component, "require");
}
function require_predicate(component) { return head(tail(component)); }
      </JAVASCRIPT>
    </SNIPPET>
    e uma nova cláusula no despacho em <SCHEMEINLINE>analyze</SCHEMEINLINE>
    <SNIPPET EVAL="no">
      <SCHEME>
      ((require? exp) (analyze-require exp))
      </SCHEME>
      <JAVASCRIPT>
: is_require(component)
? analyze_require(component)
      </JAVASCRIPT>
    </SNIPPET>
    assim como a
    <SPLITINLINE>
      <SCHEME>procedure</SCHEME>
      <JAVASCRIPT>função</JAVASCRIPT>
    </SPLITINLINE>
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>analyze-require</SCHEMEINLINE>
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>analyze_require</JAVASCRIPTINLINE>
      </JAVASCRIPT>
    </SPLITINLINE>
    que lida com expressões <SCHEMEINLINE>require</SCHEMEINLINE>. Complete a seguinte definição de
    <SPLITINLINE>
      <SCHEME>
	<SCHEMEINLINE>analyze-require</SCHEMEINLINE>.
      </SCHEME>
      <JAVASCRIPT>
	<JAVASCRIPTINLINE>analyze_require</JAVASCRIPTINLINE>.
      </JAVASCRIPT>
    </SPLITINLINE>
    <SNIPPET EVAL="no" LATEX="yes" POSTPADDING="no">
      <SCHEME>
(define (analyze-require exp)
  (let ((pproc (analyze (require-predicate exp))))
    (lambda (env succeed fail)
      (pproc env
             (lambda (pred-value fail2)
               (if ??
                   ??
                   (succeed 'ok fail2)))
             fail))))
      </SCHEME>
      <JAVASCRIPT>
function analyze_require(component) {
    const pfun = analyze(require_predicate(component));
    return (env, succeed, fail) =>
             pfun(env,
                  (pred_value, fail2) =>
                    <METAPHRASE>??</METAPHRASE>
                    ? <METAPHRASE>??</METAPHRASE>
                    : succeed("ok", fail2),
                  fail);
}
      </JAVASCRIPT>
    </SNIPPET>
  </EXERCISE>

  <INDEX>nondeterministic evaluator<CLOSE/></INDEX>

  <SNIPPET HIDE="yes">
    <NAME>all_solutions</NAME>
    <REQUIRES>ambeval</REQUIRES>
      <JAVASCRIPT>
function all_solutions(input) {
    let solutions = null;
    function internal_loop(input, retry) {
        if (input === "retry") {
            return retry();
        } else {
            return ambeval(parse("{ " + input + " }"),
                       the_global_environment,
                       // ambeval sucesso
                       (val, next_alternative) => {
                           solutions = pair(val, solutions);
                           return internal_loop("retry", next_alternative);
                       },
                       // ambeval falha
                       () => undefined
                      );
        }
    }
    internal_loop(
               input,
               () => {
                   display("// internal error");
               });
    return reverse(solutions);
}
      </JAVASCRIPT>
    </SNIPPET>
  <SNIPPET HIDE="yes">
    <NAME>first_solution</NAME>
    <REQUIRES>ambeval</REQUIRES>
      <JAVASCRIPT>
function first_solution(input) {
    return ambeval(parse("{ " + input + " }"),
                   the_global_environment,
                   (val, next_alternative) => val,
                   () => undefined);
}
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_1</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <EXPECTED>[ 'apple', [ 'banana', [ 'cranberry', null ] ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions("                                            \
function require(p) {                                      \
    return ! p ? amb() : 'Satisfied require';              \
    }                                                      \
function an_element_of(items) {                            \
    require(! is_null(items));                             \
    return amb(head(items), an_element_of(tail(items)));   \
}                                                          \
const xs = list('apple', 'banana', 'cranberry');           \
an_element_of(xs);	                                   ");
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_2</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <EXPECTED>[ 8, [ 35, null ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions("                                            \
function require(p) {                                      \
    return ! p ? amb() : 'Satisfied require';              \
    }                                                      \
function an_element_of(items) {                            \
    require(! is_null(items));                             \
    return amb(head(items), an_element_of(tail(items)));   \
}                                                          \
function square(x) {                                       \
    return x * x;                                          \
}                                                          \
function is_divisible(x, y) {                              \
    return x % y === 0;                                    \
}                                                          \
function integers_starting_from(n) {                       \
    return pair(n,                                         \
                () => integers_starting_from(n + 1)        \
               );                                          \
}                                                          \
function is_prime(n) {                                     \
    function iter(ps) {                                    \
        return square(head(ps)) &gt; n                        \
               ? true                                      \
               : is_divisible(n, head(ps))                 \
                 ? false                                   \
                 : iter(stream_tail(ps));                  \
    }                                                      \
    return iter(primes);                                   \
}                                                          \
function stream_tail(xs) {                                 \
    return tail(xs)();                                     \
}                                                          \
function stream_filter(pred, s) {                          \
    return is_null(s)                                      \
           ? null                                          \
           : pred(head(s))                                 \
             ? pair(head(s),                               \
                    () => stream_filter(pred,              \
                                        stream_tail(s)))   \
             : stream_filter(pred,                         \
                             stream_tail(s));              \
}                                                          \
const primes = pair(2,                                     \
                    () => stream_filter(                   \
                              is_prime,                    \
                              integers_starting_from(3))   \
                   );                                      \
function prime_sum_pair(list1, list2) {                    \
    const a = an_element_of(list1);                        \
    const b = an_element_of(list2);                        \
    require(is_prime(a + b));                              \
    return list(a, b);                                     \
}                                                          \
prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));       ");
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
list_ref(all_solutions("                                            \
function require(p) {                                      \
    return ! p ? amb() : 'Satisfied require';              \
    }                                                      \
function an_element_of(items) {                            \
    require(! is_null(items));                             \
    return amb(head(items), an_element_of(tail(items)));   \
}                                                          \
function square(x) {                                       \
    return x * x;                                          \
}                                                          \
function is_divisible(x, y) {                              \
    return x % y === 0;                                    \
}                                                          \
function integers_starting_from(n) {                       \
    return pair(n,                                         \
                () => integers_starting_from(n + 1)        \
               );                                          \
}                                                          \
function is_prime(n) {                                     \
    function iter(ps) {                                    \
        return square(head(ps)) &gt; n                        \
               ? true                                      \
               : is_divisible(n, head(ps))                 \
                 ? false                                   \
                 : iter(stream_tail(ps));                  \
    }                                                      \
    return iter(primes);                                   \
}                                                          \
function stream_tail(xs) {                                 \
    return tail(xs)();                                     \
}                                                          \
function stream_filter(pred, s) {                          \
    return is_null(s)                                      \
           ? null                                          \
           : pred(head(s))                                 \
             ? pair(head(s),                               \
                    () => stream_filter(pred,              \
                                        stream_tail(s)))   \
             : stream_filter(pred,                         \
                             stream_tail(s));              \
}                                                          \
const primes = pair(2,                                     \
                    () => stream_filter(                   \
                              is_prime,                    \
                              integers_starting_from(3))   \
                   );                                      \
function prime_sum_pair(list1, list2) {                    \
    const a = an_element_of(list1);                        \
    const b = an_element_of(list2);                        \
    require(is_prime(a + b));                              \
    return list(a, b);                                     \
}                                                          \
prime_sum_pair(list(1, 3, 5, 8), list(20, 35, 110));       "),
      4);
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_3</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <EXPECTED>[ 'verb', [ 'eats', null ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions("                                                      \
function require(p) {                                                \
    return ! p ? amb() : 'Satisfied require';                        \
}                                                                    \
function member(item, x) {                                           \
    return is_null(x)                                                \
        ? null                                                       \
        : item === head(x)                                           \
          ? x                                                        \
          : member(item, tail(x));                                   \
}                                                                    \
let unparsed = null;                                                 \
const nouns = list('noun', 'student', 'professor', 'cat', 'class');  \
const verbs = list('verb', 'studies', 'lectures', 'eats', 'sleeps'); \
const articles = list('article', 'the', 'a');                        \
function parse_word(word_list) {                                     \
    require(! is_null(unparsed));                                    \
    require(! is_null(member(head(unparsed), tail(word_list))));     \
    const found_word = head(unparsed);                               \
    unparsed = tail(unparsed);                                       \
    return list(head(word_list), found_word);                        \
}                                                                    \
function parse_noun_phrase() {                                       \
    return list('noun-phrase',                                       \
                parse_word(articles),                                \
                parse_word(nouns));                                  \
}                                                                    \
function parse_sentence() {                                          \
    return list('sentence',                                          \
                parse_noun_phrase(),                                 \
                parse_word(verbs));                                  \
}                                                                    \
function parse_input(input) {                                        \
    unparsed = input;                                                \
    const sent = parse_sentence();                                   \
    require(is_null(unparsed));                                      \
    return sent;                                                     \
}                                                                    \
parse_input(list('the',  'cat',  'eats'));                           ");
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
list_ref(list_ref(all_solutions("                                                      \
function require(p) {                                                \
    return ! p ? amb() : 'Satisfied require';                        \
}                                                                    \
function member(item, x) {                                           \
    return is_null(x)                                                \
        ? null                                                       \
        : item === head(x)                                           \
          ? x                                                        \
          : member(item, tail(x));                                   \
}                                                                    \
let unparsed = null;                                                 \
const nouns = list('noun', 'student', 'professor', 'cat', 'class');  \
const verbs = list('verb', 'studies', 'lectures', 'eats', 'sleeps'); \
const articles = list('article', 'the', 'a');                        \
function parse_word(word_list) {                                     \
    require(! is_null(unparsed));                                    \
    require(! is_null(member(head(unparsed), tail(word_list))));     \
    const found_word = head(unparsed);                               \
    unparsed = tail(unparsed);                                       \
    return list(head(word_list), found_word);                        \
}                                                                    \
function parse_noun_phrase() {                                       \
    return list('noun-phrase',                                       \
                parse_word(articles),                                \
                parse_word(nouns));                                  \
}                                                                    \
function parse_sentence() {                                          \
    return list('sentence',                                          \
                parse_noun_phrase(),                                 \
                parse_word(verbs));                                  \
}                                                                    \
function parse_input(input) {                                        \
    unparsed = input;                                                \
    const sent = parse_sentence();                                   \
    require(is_null(unparsed));                                      \
    return sent;                                                     \
}                                                                    \
parse_input(list('the',  'cat',  'eats'));                           "),
                 0),
        2);
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>full_parser</NAME>
      <JAVASCRIPT>
const full_parser = "                                                \
function require(p) {                                                \
    return ! p ? amb() : 'Satisfied require';                        \
}                                                                    \
function member(item, x) {                                           \
    return is_null(x)                                                \
        ? null                                                       \
        : item === head(x)                                           \
          ? x                                                        \
          : member(item, tail(x));                                   \
}                                                                    \
let unparsed = null;                                                 \
function parse_word(word_list) {                                     \
    require(! is_null(unparsed));                                    \
    require(! is_null(member(head(unparsed), tail(word_list))));     \
    const found_word = head(unparsed);                               \
    unparsed = tail(unparsed);                                       \
    return list(head(word_list), found_word);                        \
}                                                                    \
const prepositions = list('prep', 'for', 'to',  'in', 'by', 'with'); \
function parse_prepositional_phrase() {                              \
    return list('prep-phrase',                                       \
                parse_word(prepositions),                            \
                parse_noun_phrase());                                \
}                                                                    \
const nouns = list('noun', 'student', 'professor', 'cat', 'class');  \
const verbs = list('verb', 'studies', 'lectures', 'eats', 'sleeps'); \
                                                                     \
const articles = list('article', 'the', 'a');                        \
function parse_simple_noun_phrase() {                                \
    return list('simple-noun-phrase',                                \
                parse_word(articles),                                \
                parse_word(nouns));                                  \
}                                                                    \
function parse_noun_phrase() {                                       \
    function maybe_extend(noun_phrase) {                             \
        return amb(noun_phrase,                                      \
                   maybe_extend(list('noun-phrase',                  \
                                 noun_phrase,                        \
                                 parse_prepositional_phrase())));    \
    }                                                                \
    return maybe_extend(parse_simple_noun_phrase());                 \
}                                                                    \
function parse_sentence() {                                          \
    return list('sentence',                                          \
                parse_noun_phrase(),                                 \
                parse_verb_phrase());                                \
}                                                                    \
function parse_verb_phrase() {                                       \
    function maybe_extend(verb_phrase) {                             \
        return amb(verb_phrase,                                      \
                   maybe_extend(list('verb-phrase',                  \
                                 verb_phrase,                        \
                                 parse_prepositional_phrase())));    \
    }		                                                     \
    return maybe_extend(parse_word(verbs));                          \
}                                                                    \
function parse_input(input) {                                        \
    unparsed = input;                                                \
    const sent = parse_sentence();                                   \
    require(is_null(unparsed));                                      \
    return sent;                                                     \
}                                                                    ";
      </JAVASCRIPT>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_4</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <REQUIRES>full_parser</REQUIRES>
      <EXPECTED>[ 'article', [ 'the', null ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions(full_parser +
"                                                                   \
parse_input(list('the', 'student', 'with', 'the', 'cat',            \
'sleeps', 'in', 'the', 'class'));                                   ");
      </JAVASCRIPT>
      <JAVASCRIPT_RUN>
list_ref(list_ref(list_ref(list_ref(list_ref(all_solutions(full_parser +
"                                                                   \
parse_input(list('the', 'student', 'with', 'the', 'cat',            \
'sleeps', 'in', 'the', 'class'));                                   "),
                                             0),
                                    2),
                           2),
                  2),
         1);
      </JAVASCRIPT_RUN>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>all_solutions_test_5</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <REQUIRES>full_parser</REQUIRES>
      <EXPECTED>[ 'prep', [ 'with', null ] ]</EXPECTED>
      <JAVASCRIPT>
all_solutions(full_parser +
"                                                                   \
parse_input(list('the', 'professor', 'lectures',                    \
                 'to', 'the', 'student', 'with', 'the', 'cat'));    ");
      </JAVASCRIPT>
      <JAVASCRIPT_TEST>
list_ref(list_ref(list_ref(list_ref(list_ref(list_ref(all_solutions(full_parser +
"                                                                   \
parse_input(list('the', 'professor', 'lectures',                    \
                 'to', 'the', 'student', 'with', 'the', 'cat'));    "),
                                                      1),
                                             2),
                                    2),
                           2),
                  2),
         1);
      </JAVASCRIPT_TEST>
    </SNIPPET>
    <SNIPPET HIDE="yes">
      <NAME>first_solutions_test_1</NAME>
      <REQUIRES>first_solution</REQUIRES>
      <REQUIRES>all_solutions</REQUIRES>
      <!-- No test case: command line version seems
	   too slow for this puzzle
      <EXPECTED>what</EXPECTED>                         -->
      <JAVASCRIPT>
first_solution("                                                     \
function require(p) {                                                \
    return ! p ? amb() : 'Satisfied require';                        \
}                                                                    \
function distinct(items) {                                           \
    return is_null(items)                                            \
        ? true                                                       \
        : is_null(tail(items))                                       \
          ? true                                                     \
          : is_null(member(head(items), tail(items)))                \
            ? distinct(tail(items))                                  \
            : false;                                                 \
}                                                                    \
function member(item, x) {                                           \
    return is_null(x)                                                \
        ? null                                                       \
        : item === head(x)                                           \
          ? x                                                        \
          : member(item, tail(x));                                   \
}                                                                    \
function multiple_dwelling() {                                       \
    const baker = amb(1, 2, 3, 4, 5);                                \
    const cooper = amb(1, 2, 3, 4, 5);                               \
    const fletcher = amb(1, 2, 3, 4, 5);                             \
    const miller = amb(1, 2, 3, 4, 5);                               \
    const smith = amb(1, 2, 3, 4, 5);                                \
    require(distinct(list(baker, cooper, fletcher, miller, smith))); \
    require(! (baker === 5));                                        \
    require(! (cooper === 1));                                       \
    require(! (fletcher === 5));                                     \
    require(! (fletcher === 1));                                     \
    require(miller &gt; cooper);                                        \
    require(! (math_abs(smith - fletcher) === 1));                   \
    require(! (math_abs(fletcher - cooper) === 1));                  \
    return list(list('baker', baker),                                \
                list('cooper', cooper),                              \
                list('fletcher', fletcher),                          \
                list('miller', miller),                              \
                list('smith', smith));                               \
}                                                                    \
multiple_dwelling();                                                 ");
      </JAVASCRIPT>
    </SNIPPET>
</SUBSECTION>
