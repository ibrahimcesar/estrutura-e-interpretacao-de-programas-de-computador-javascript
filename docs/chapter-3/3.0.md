# 3 Modularidade, Objetos e Estado

>Μεταβάλλον ἀναπαύεται
>
>(Mesmo enquanto muda, permanece imóvel.)
>
>— Heráclito

>Plus ça change, plus c'est la même chose.
>
>— Alphonse Karr

Os capítulos anteriores introduziram os elementos básicos a partir dos quais os programas são construídos. Vimos como funções primitivas e dados primitivos são combinados para construir entidades compostas, e aprendemos que a abstração é vital para nos ajudar a lidar com a complexidade de sistemas grandes. Mas essas ferramentas não são suficientes para projetar programas. A síntese efetiva de programas também requer princípios organizacionais que possam nos guiar na formulação do design geral de um programa. Em particular, precisamos de estratégias para nos ajudar a estruturar sistemas grandes de modo que sejam *modulares*, isto é, para que possam ser divididos "naturalmente" em partes coerentes que possam ser desenvolvidas e mantidas separadamente.

Uma estratégia de design poderosa, que é particularmente apropriada para a construção de programas para modelagem de sistemas físicos, é basear a estrutura de nossos programas na estrutura do sistema sendo modelado. Para cada objeto no sistema, construímos um objeto computacional correspondente. Para cada ação do sistema, definimos uma operação simbólica em nosso modelo computacional. Nossa esperança ao usar essa estratégia é que estender o modelo para acomodar novos objetos ou novas ações não exigirá mudanças estratégicas no programa, apenas a adição dos novos análogos simbólicos desses objetos ou ações. Se formos bem-sucedidos em nossa organização do sistema, então para adicionar uma nova funcionalidade ou depurar uma antiga, teremos que trabalhar apenas em uma parte localizada do sistema.

Em grande medida, então, a maneira como organizamos um programa grande é ditada por nossa percepção do sistema a ser modelado. Neste capítulo investigaremos duas estratégias organizacionais proeminentes que surgem de duas "visões de mundo" bastante diferentes da estrutura dos sistemas. A primeira estratégia organizacional concentra-se em *objetos*, vendo um sistema grande como uma coleção de objetos distintos cujos comportamentos podem mudar ao longo do tempo. Uma estratégia organizacional alternativa concentra-se nos *streams* de informação que fluem no sistema, muito parecido com a forma como um engenheiro elétrico vê um sistema de processamento de sinais.

Tanto a abordagem baseada em objetos quanto a abordagem de processamento de streams levantam questões linguísticas significativas em programação. Com objetos, devemos nos preocupar com como um objeto computacional pode mudar e ainda manter sua identidade. Isso nos forçará a abandonar nosso antigo modelo de substituição de computação (seção 1.1.5) em favor de um *modelo de ambiente* de computação mais mecanicista, mas menos tratável teoricamente. As dificuldades de lidar com objetos, mudança e identidade são uma consequência fundamental da necessidade de lidar com o tempo em nossos modelos computacionais. Essas dificuldades tornam-se ainda maiores quando permitimos a possibilidade de execução concorrente de programas. A abordagem de streams pode ser mais plenamente explorada quando desacoplamos o tempo simulado em nosso modelo da ordem dos eventos que ocorrem no computador durante a avaliação. Conseguiremos isso usando uma técnica conhecida como *avaliação atrasada*.
